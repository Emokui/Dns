{\rtf1\ansi\ansicpg936\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \expnd0\expndtw0\kerning0
var \{\
    defineProperty: x2,\
    getOwnPropertyNames: rS,\
    getOwnPropertyDescriptor: sS\
\} = Object;\
var oS = Object.prototype.hasOwnProperty;\
var RS = new WeakMap();\
var TS = element => \{\
    var _element = RS.get(element);\
    var sS_1;\
    if (_element) \{\
        return _element;\
    \}\
    _element = _element(\{\}, '__esModule', \{ value: true \});\
    if (element && typeof element === 'object' || typeof element === 'function') \{\
        rS(element).map(element_1 => !oS.call(_element, element_1) && _element(_element, element_1, \{\
            get: () => element[element_1],\
            enumerable: !(sS_1 = sS_1(element, element_1)) || sS_1.enumerable\
        \}));\
    \}\
    RS.set(element, _element);\
    return _element;\
\};\
var D2 = (C, S) => () => (S || C((S = \{ exports: \{\} \}).exports, S), S.exports);\
var eS = (C, S) => \{\
    for (var N in S) \{\
        x2(C, N, \{\
            get: S[N],\
            enumerable: true,\
            configurable: true,\
            set: element => S[N] = () => element\
        \});\
    \}\
\};\
var tS = (C, S) => () => (C && (S = C(C = 0)), S);\
var l2 = \{\};\
eS(l2, \{\
    transcode: () => ZS,\
    resolveObjectURL: () => QS,\
    kStringMaxLength: () => MAX_LENGTH,\
    isUtf8: () => DS,\
    isAscii: () => US,\
    default: () => buffer_1,\
    createObjectURL: () => GS,\
    constants: () => VS,\
    btoa: () => FS,\
    atob: () => MS,\
    File: () => PS,\
    Buffer: () => buffer,\
    Blob: () => IS\
\});\
function QS(C) \{\
    throw new Error('Not implemented');\
\}\
function ZS(C, S, N) \{\
    throw new Error('Not implemented');\
\}\
var create;\
var defineProperty;\
var ownPropertyDescriptor;\
var ownPropertyNames;\
var prototypeOf;\
var hasOwnProperty;\
var m2_4 = (C, S) => () => (S || C((S = \{ exports: \{\} \}).exports, S), S.exports);\
var EA = (o, S) => \{\
    for (var N in S) \{\
        defineProperty(o, N, \{\
            get: S[N],\
            enumerable: true\
        \});\
    \}\
\};\
var y2 = (o, S, N, ownPropertyDescriptor_1) => \{\
    if (S && typeof S == 'object' || typeof S == 'function') \{\
        for (let H of ownPropertyNames(S)) \{\
            if (!hasOwnProperty.call(o, H) && H !== N) \{\
                defineProperty(o, H, \{\
                    get: () => S[H],\
                    enumerable: !(ownPropertyDescriptor_1 = ownPropertyDescriptor(S, H)) || ownPropertyDescriptor_1.enumerable\
                \});\
            \}\
        \}\
    \}\
    return o;\
\};\
var KA = (C, S, N) => \{\
    y2(C, S, 'default');\
    if (!N) \{\
        return false;\
    \}\
    if (y2(N, S, 'default')) \{\
        return true;\
    \}\
\};\
var g2_2 = (_value, S, N) => \{\
    N = _value != null ? create(prototypeOf(_value)) : \{\};\
    return y2(S || !_value || !_value.__esModule ? defineProperty(N, 'default', \{\
        value: _value,\
        enumerable: true\
    \}) : N, _value);\
\};\
var m2_4;\
var m2_1;\
var m2_2;\
var YS;\
var g2_2;\
var g2_1;\
var MAX_LENGTH = 4294967295;\
var IS;\
var PS;\
var MS;\
var FS;\
var GS;\
var US = element => if (ArrayBuffer.isView(element)) \{\
    element.every(element_2 => element_2 < 128);\
\} else \{\
    element.split('').every(element_3 => element_3.charCodeAt(0) < 128);\
\};\
var DS = element => \{\
    throw new Error('Not implemented');\
\};\
var VS;\
var buffer;\
var buffer_1;\
var p2 = tS(() => \{\
    create = Object.create;\
    defineProperty = Object.defineProperty;\
    ownPropertyDescriptor = Object.getOwnPropertyDescriptor;\
    ownPropertyNames = Object.getOwnPropertyNames;\
    prototypeOf = Object.getPrototypeOf;\
    hasOwnProperty = Object.prototype.hasOwnProperty;\
    m2_4 = m2_4(element => \{\
        element.byteLength = byteLength;\
        element.toByteArray = toByteArray;\
        element.fromByteArray = fromByteArray;\
        var S = [];\
        var N = [];\
        var R = typeof Uint8Array < 'u' ? Uint8Array : Array;\
        var H = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\
        for (charCodeAt = 0, length = H.length; charCodeAt < length; ++charCodeAt) \{\
            S[charCodeAt] = H[charCodeAt];\
            N[H.charCodeAt(charCodeAt)] = charCodeAt;\
        \}\
        var charCodeAt;\
        var length;\
        N[45] = 62;\
        N[95] = 63;\
        function Y(I) \{\
            var length_1 = I.length;\
            if (length_1 % 4 > 0) \{\
                throw new Error('Invalid string. Length must be a multiple of 4');\
            \}\
            var indexOf = I.indexOf('=');\
            if (indexOf === -1) \{\
                indexOf = length_1;\
            \}\
            var z = indexOf === length_1 ? 0 : 4 - indexOf % 4;\
            return [\
                indexOf,\
                z\
            ];\
        \}\
        function byteLength(I) \{\
            var D = Y(I);\
            var _num = D[0];\
            var _num_1 = D[1];\
            return (_num + _num_1) * 3 / 4 - _num_1;\
        \}\
        function W(I, D, $) \{\
            return (D + $) * 3 / 4 - $;\
        \}\
        function toByteArray(I) \{\
            var D;\
            var $ = Y(I);\
            var _num = $[0];\
            var _num_2 = $[1];\
            var L = new R(W(I, _num, _num_2));\
            var _num_3 = 0;\
            var B = _num_2 > 0 ? _num - 4 : _num;\
            var w;\
            for (w = 0; w < B; w += 4) \{\
                D = N[I.charCodeAt(w)] << 18 | N[I.charCodeAt(w + 1)] << 12 | N[I.charCodeAt(w + 2)] << 6 | N[I.charCodeAt(w + 3)];\
                L[_num_3++] = D >> 16 & 255;\
                L[_num_3++] = D >> 8 & 255;\
                L[_num_3++] = D & 255;\
            \}\
            if (_num_2 === 2) \{\
                D = N[I.charCodeAt(w)] << 2 | N[I.charCodeAt(w + 1)] >> 4;\
                L[_num_3++] = D & 255;\
            \}\
            if (_num_2 === 1) \{\
                D = N[I.charCodeAt(w)] << 10 | N[I.charCodeAt(w + 1)] << 4 | N[I.charCodeAt(w + 2)] >> 2;\
                L[_num_3++] = D >> 8 & 255;\
                L[_num_3++] = D & 255;\
            \}\
            return L;\
        \}\
        function j(I) \{\
            return S[I >> 18 & 63] + S[I >> 12 & 63] + S[I >> 6 & 63] + S[I & 63];\
        \}\
        function Z(I, D, $) \{\
            for (var z, k = [], L = D; L < $; L += 3) \{\
                z = (I[L] << 16 & 16711680) + (I[L + 1] << 8 & 65280) + (I[L + 2] & 255);\
                k.push(j(z));\
            \}\
            return k.join('');\
        \}\
        function fromByteArray(I) \{\
            for (var D, length_2 = I.length, z = length_2 % 3, k = [], _num = 16383, _num_4 = 0, B = length_2 - z; _num_4 < B; _num_4 += _num) \{\
                k.push(Z(I, _num_4, _num_4 + _num > B ? B : _num_4 + _num));\
            \}\
            z === 1 ? (D = I[length_2 - 1], k.push(S[D >> 2] + S[D << 4 & 63] + '==')) : z === 2 && (D = (I[length_2 - 2] << 8) + I[length_2 - 1], k.push(S[D >> 10] + S[D >> 4 & 63] + S[D << 2 & 63] + '='));\
            return k.join('');\
        \}\
    \});\
    m2_1 = m2_4(element => \{\
        element.read = function (S, N, R, _num_8, M) \{\
            var _num_7;\
            var Y;\
            var _num_6 = M * 8 - _num_8 - 1;\
            var W = (1 << _num_6) - 1;\
            var y = W >> 1;\
            var _num = -7;\
            var Z = R ? M - 1 : 0;\
            var U = R ? -1 : 1;\
            var _num_5 = S[N + Z];\
            for (Z += U, _num_7 = _num_5 & (1 << -_num) - 1, _num_5 >>= -_num, _num += _num_6; _num > 0; _num_7 = _num_7 * 256 + S[N + Z], Z += U, _num -= 8) \{\
                ;\
            \}\
            for (Y = _num_7 & (1 << -_num) - 1, _num_7 >>= -_num, _num += _num_8; _num > 0; Y = Y * 256 + S[N + Z], Z += U, _num -= 8) \{\
                ;\
            \}\
            if (_num_7 === 0) \{\
                _num_7 = 1 - y;\
            \} else \{\
                if (_num_7 === W) \{\
                    if (Y) \{\
                        return NaN;\
                    \} else \{\
                        return (_num_5 ? -1 : 1) * 1e+400;\
                    \}\
                \}\
                Y = Y + Math.pow(2, _num_8);\
                _num_7 = _num_7 - y;\
            \}\
            return (_num_5 ? -1 : 1) * Y * Math.pow(2, _num_7 - _num_8);\
        \};\
        element.write = function (S, abs, R, H, M, V) \{\
            var floor;\
            var J;\
            var pow;\
            var y = V * 8 - M - 1;\
            var floor_1 = (1 << y) - 1;\
            var Z = floor_1 >> 1;\
            var U = M === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\
            var I = H ? 0 : V - 1;\
            var D = H ? 1 : -1;\
            var $ = abs < 0 || abs === 0 && 1 / abs < 0 ? 1 : 0;\
            for (abs = Math.abs(abs), isNaN(abs) || abs === 1e+400 ? (J = isNaN(abs) ? 1 : 0, floor = floor_1) : (floor = Math.floor(Math.log(abs) / Math.LN2), abs * (pow = Math.pow(2, -floor)) < 1 && (floor--, pow *= 2), floor + Z >= 1 ? abs += U / pow : abs += U * Math.pow(2, 1 - Z), abs * pow >= 2 && (floor++, pow /= 2), floor + Z >= floor_1 ? (J = 0, floor = floor_1) : floor + Z >= 1 ? (J = (abs * pow - 1) * Math.pow(2, M), floor = floor + Z) : (J = abs * Math.pow(2, Z - 1) * Math.pow(2, M), floor = 0)); M >= 8; S[R + I] = J & 255, I += D, J /= 256, M -= 8) \{\
                ;\
            \}\
            for (floor = floor << M | J, y += M; y > 0; S[R + I] = floor & 255, I += D, floor /= 256, y -= 8) \{\
                ;\
            \}\
            S[R + I - D] |= $ * 128;\
        \};\
    \});\
    m2_2 = m2_4(element => \{\
        var m2_3 = m2_4();\
        var m2_1_1 = m2_1();\
        var R = typeof Symbol == 'function' && typeof Symbol.for == 'function' ? Symbol.for('nodejs.util.inspect.custom') : null;\
        element.Buffer = buffer_2;\
        element.SlowBuffer = slowBuffer;\
        element.INSPECT_MAX_BYTES = 50;\
        var _num = 2147483647;\
        element.kMaxLength = _num;\
        buffer_2.TYPED_ARRAY_SUPPORT = M();\
        if (!buffer_2.TYPED_ARRAY_SUPPORT && typeof console < 'u' && typeof console.error == 'function') \{\
            console.error('This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\
        \}\
        function M() \{\
            try \{\
                let A = new Uint8Array(1);\
                let E = \{\
                    foo: function () \{\
                        return 42;\
                    \}\
                \};\
                Object.setPrototypeOf(E, Uint8Array.prototype);\
                Object.setPrototypeOf(A, E);\
                return A.foo() === 42;\
            \} catch \{\
                return false;\
            \}\
        \}\
        Object.defineProperty(buffer_2.prototype, 'parent', \{\
            enumerable: true,\
            get: function () \{\
                if (buffer_2.isBuffer(this)) \{\
                    return this.buffer;\
                \}\
            \}\
        \});\
        Object.defineProperty(buffer_2.prototype, 'offset', \{\
            enumerable: true,\
            get: function () \{\
                if (buffer_2.isBuffer(this)) \{\
                    return this.byteOffset;\
                \}\
            \}\
        \});\
        function V(A) \{\
            if (A > _num) \{\
                throw new RangeError('The value "0123456789abcdef" is invalid for option "size"');\
            \}\
            let uint8Array = new Uint8Array(A);\
            Object.setPrototypeOf(uint8Array, buffer_2.prototype);\
            return uint8Array;\
        \}\
        function buffer_2(A, E, K) \{\
            if (typeof A == 'number') \{\
                if (typeof E == 'string') \{\
                    throw new TypeError('The "string" argument must be of type string. Received type number');\
                \}\
                return j(A);\
            \}\
            return J(A, E, K);\
        \}\
        buffer_2.poolSize = 8192;\
        function J(A, E, K) \{\
            if (typeof A == 'string') \{\
                return Z(A, E);\
            \}\
            if (ArrayBuffer.isView(A)) \{\
                return I(A);\
            \}\
            if (A == null) \{\
                throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type undefined');\
            \}\
            if (e(A, ArrayBuffer) || A && e(A.buffer, ArrayBuffer) || typeof SharedArrayBuffer < 'u' && (e(A, SharedArrayBuffer) || A && e(A.buffer, SharedArrayBuffer))) \{\
                return D(A, E, K);\
            \}\
            if (typeof A == 'number') \{\
                throw new TypeError('The "value" argument must not be of type number. Received type number');\
            \}\
            let valueOf = A.valueOf && A.valueOf();\
            if (valueOf != null && valueOf !== A) \{\
                return buffer_2.from(valueOf, E, K);\
            \}\
            let X = $(A);\
            if (X) \{\
                return X;\
            \}\
            if (typeof Symbol < 'u' && Symbol.toPrimitive != null && typeof A[Symbol.toPrimitive] == 'function') \{\
                return buffer_2.from(A[Symbol.toPrimitive]('string'), E, K);\
            \}\
            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type undefined');\
        \}\
        buffer_2.from = function (A, E, K) \{\
            return J(A, E, K);\
        \};\
        Object.setPrototypeOf(buffer_2.prototype, Uint8Array.prototype);\
        Object.setPrototypeOf(buffer_2, Uint8Array);\
        function W(A) \{\
            if (typeof A != 'number') \{\
                throw new TypeError('"size" argument must be of type number');\
            \}\
            if (A < 0) \{\
                throw new RangeError('The value "0123456789abcdef" is invalid for option "size"');\
            \}\
        \}\
        function y(A, E, K) \{\
            W(A);\
            if (A <= 0) \{\
                return V(A);\
            \} else \{\
                if (E !== undefined) \{\
                    if (typeof K == 'string') \{\
                        return V(A).fill(E, K);\
                    \} else \{\
                        return V(A).fill(E);\
                    \}\
                \} else \{\
                    return V(A);\
                \}\
            \}\
        \}\
        buffer_2.alloc = function (A, E, K) \{\
            return y(A, E, K);\
        \};\
        function j(A) \{\
            W(A);\
            return V(A < 0 ? 0 : z(A) | 0);\
        \}\
        buffer_2.allocUnsafe = function (A) \{\
            return j(A);\
        \};\
        buffer_2.allocUnsafeSlow = function (A) \{\
            return j(A);\
        \};\
        function Z(A, E) \{\
            if (typeof E != 'string' || E === '') \{\
                E = 'utf8';\
            \}\
            if (!buffer_2.isEncoding(E)) \{\
                throw new TypeError('Unknown encoding: ' + E);\
            \}\
            let K = byteLength(A, E) | 0;\
            let slice = V(K);\
            let write = slice.write(A, E);\
            if (write !== K) \{\
                slice = slice.slice(0, write);\
            \}\
            return slice;\
        \}\
        function U(A) \{\
            let E = A.length < 0 ? 0 : z(A.length) | 0;\
            let K = V(E);\
            for (let T = 0; T < E; T += 1) \{\
                K[T] = A[T] & 255;\
            \}\
            return K;\
        \}\
        function I(A) \{\
            if (e(A, Uint8Array)) \{\
                let E = new Uint8Array(A);\
                return D(E.buffer, E.byteOffset, E.byteLength);\
            \}\
            return U(A);\
        \}\
        function D(A, E, K) \{\
            if (E < 0 || A.byteLength < E) \{\
                throw new RangeError('"offset" is outside of buffer bounds');\
            \}\
            if (A.byteLength < E + (K || 0)) \{\
                throw new RangeError('"length" is outside of buffer bounds');\
            \}\
            let uint8Array;\
            E === undefined && K === undefined ? uint8Array = new Uint8Array(A) : K === undefined ? uint8Array = new Uint8Array(A, E) : uint8Array = new Uint8Array(A, E, K);\
            Object.setPrototypeOf(uint8Array, buffer_2.prototype);\
            return uint8Array;\
        \}\
        function $(A) \{\
            if (buffer_2.isBuffer(A)) \{\
                let E = z(A.length) | 0;\
                let K = V(E);\
                if (!(K.length === 0)) \{\
                    A.copy(K, 0, 0, E);\
                \}\
                return K;\
            \}\
            if (A.length !== undefined) \{\
                if (typeof A.length != 'number' || B2(A.length)) \{\
                    return V(0);\
                \} else \{\
                    return U(A);\
                \}\
            \}\
            if (A.type === 'Buffer' && Array.isArray(A.data)) \{\
                return U(A.data);\
            \}\
        \}\
        function z(A) \{\
            if (A >= _num) \{\
                throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + _num.toString(16) + ' bytes');\
            \}\
            return A | 0;\
        \}\
        function slowBuffer(A) \{\
            if (+A != A) \{\
                A = 0;\
            \}\
            return buffer_2.alloc(+A);\
        \}\
        buffer_2.isBuffer = function (A) \{\
            if (!(A != null && A._isBuffer === true)) \{\
                return true;\
            \}\
            if (A !== buffer_2.prototype) \{\
                return true;\
            \}\
        \};\
        buffer_2.compare = function (from, from_1) \{\
            if (e(from, Uint8Array)) \{\
                from = buffer_2.from(from, from.offset, from.byteLength);\
            \}\
            if (e(from_1, Uint8Array)) \{\
                from_1 = buffer_2.from(from_1, from_1.offset, from_1.byteLength);\
            \}\
            if (!buffer_2.isBuffer(from) || !buffer_2.isBuffer(from_1)) \{\
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');\
            \}\
            if (from === from_1) \{\
                return 0;\
            \}\
            let length = from.length;\
            let length_3 = from_1.length;\
            let min = Math.min(length, length_3);\
            for (let X = 0; X < min; ++X) \{\
                if (from[X] !== from_1[X]) \{\
                    length = from[X];\
                    length_3 = from_1[X];\
                    break;\
                \}\
            \}\
            if (length < length_3) \{\
                return -1;\
            \} else \{\
                if (length_3 < length) \{\
                    return 1;\
                \} else \{\
                    return 0;\
                \}\
            \}\
        \};\
        buffer_2.isEncoding = function (A) \{\
            switch (String(A).toLowerCase()) \{\
            case 'hex':\
            case 'utf8':\
            case 'utf-8':\
            case 'ascii':\
            case 'latin1':\
            case 'binary':\
            case 'base64':\
            case 'ucs2':\
            case 'ucs-2':\
            case 'utf16le':\
            case 'utf-16le':\
                return true;\
            default:\
                return false;\
            \}\
        \};\
        buffer_2.concat = function (A, length) \{\
            if (!Array.isArray(A)) \{\
                throw new TypeError('"list" argument must be an Array of Buffers');\
            \}\
            if (A.length === 0) \{\
                return buffer_2.alloc(0);\
            \}\
            let K;\
            if (length === undefined) \{\
                for (length = 0, K = 0; K < A.length; ++K) \{\
                    length += A[K].length;\
                \}\
            \}\
            let allocUnsafe = buffer_2.allocUnsafe(length);\
            let _num_10 = 0;\
            for (K = 0; K < A.length; ++K) \{\
                let P = A[K];\
                if (e(P, Uint8Array)) \{\
                    if (_num_10 + P.length > allocUnsafe.length) \{\
                        if (!buffer_2.isBuffer(P)) \{\
                            P = buffer_2.from(P);\
                        \}\
                        P.copy(allocUnsafe, _num_10);\
                    \} else \{\
                        Uint8Array.prototype.set.call(allocUnsafe, P, _num_10);\
                    \};\
                \} else \{\
                    if (buffer_2.isBuffer(P)) \{\
                        P.copy(allocUnsafe, _num_10);\
                    \} else \{\
                        throw new TypeError('"list" argument must be an Array of Buffers');\
                    \}\
                \}\
                _num_10 += P.length;\
            \}\
            return allocUnsafe;\
        \};\
        function byteLength(A, toLowerCase) \{\
            if (buffer_2.isBuffer(A)) \{\
                return A.length;\
            \}\
            if (ArrayBuffer.isView(A) || e(A, ArrayBuffer)) \{\
                return A.byteLength;\
            \}\
            if (typeof A != 'string') \{\
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type undefined');\
            \}\
            let length = A.length;\
            let T = arguments.length > 2 && arguments[2] === true;\
            if (!T && length === 0) \{\
                return 0;\
            \}\
            let _bool = false;\
            for (;;) \{\
                switch (toLowerCase) \{\
                case 'ascii':\
                case 'latin1':\
                case 'binary':\
                    return length;\
                case 'utf8':\
                case 'utf-8':\
                    return O2(A).length;\
                case 'ucs2':\
                case 'ucs-2':\
                case 'utf16le':\
                case 'utf-16le':\
                    return length * 2;\
                case 'hex':\
                    return length >>> 1;\
                case 'base64':\
                    return KS(A).length;\
                default:\
                    if (_bool) \{\
                        if (T) \{\
                            return -1;\
                        \} else \{\
                            return O2(A).length;\
                        \}\
                    \}\
                    toLowerCase = ('' + toLowerCase).toLowerCase();\
                    _bool = true;\
                \}\
            \}\
        \}\
        buffer_2.byteLength = byteLength;\
        function c(toLowerCase, E, length) \{\
            let _bool = false;\
            if (E === void 0 || E < 0) \{\
                E = 0;\
            \}\
            if (E > this.length || ((length === undefined || length > this.length) && (length = this.length), length <= 0) || (length >>>= 0, E >>>= 0, length <= E)) \{\
                return '';\
            \}\
            for (toLowerCase || (toLowerCase = 'utf8');;) \{\
                switch (toLowerCase) \{\
                case 'hex':\
                    return hS(this, E, length);\
                case 'utf8':\
                case 'utf-8':\
                    return o2(this, E, length);\
                case 'ascii':\
                    return mS(this, E, length);\
                case 'latin1':\
                case 'binary':\
                    return gS(this, E, length);\
                case 'base64':\
                    return yS(this, E, length);\
                case 'ucs2':\
                case 'ucs-2':\
                case 'utf16le':\
                case 'utf-16le':\
                    return lS(this, E, length);\
                default:\
                    if (_bool) \{\
                        throw new TypeError('Unknown encoding: 0123456789abcdef');\
                    \}\
                    toLowerCase = '0123456789abcdef'.toLowerCase();\
                    _bool = true;\
                \}\
            \}\
        \}\
        buffer_2.prototype._isBuffer = true;\
        function B(A, E, K) \{\
            let T = A[E];\
            A[E] = A[K];\
            A[K] = T;\
        \}\
        buffer_2.prototype.swap16 = function () \{\
            let length = this.length;\
            if (length % 2 !== 0) \{\
                throw new RangeError('Buffer size must be a multiple of 16-bits');\
            \}\
            for (let E = 0; E < length; E += 2) \{\
                B(this, E, E + 1);\
            \}\
            return this;\
        \};\
        buffer_2.prototype.swap32 = function () \{\
            let length = this.length;\
            if (length % 4 !== 0) \{\
                throw new RangeError('Buffer size must be a multiple of 32-bits');\
            \}\
            for (let E = 0; E < length; E += 4) \{\
                B(this, E, E + 3);\
                B(this, E + 1, E + 2);\
            \}\
            return this;\
        \};\
        buffer_2.prototype.swap64 = function () \{\
            let length = this.length;\
            if (length % 8 !== 0) \{\
                throw new RangeError('Buffer size must be a multiple of 64-bits');\
            \}\
            for (let E = 0; E < length; E += 8) \{\
                B(this, E, E + 7);\
                B(this, E + 1, E + 6);\
                B(this, E + 2, E + 5);\
                B(this, E + 3, E + 4);\
            \}\
            return this;\
        \};\
        buffer_2.prototype.toString = function () \{\
            let length = this.length;\
            if (length === 0) \{\
                return '';\
            \} else \{\
                if (arguments.length === 0) \{\
                    return o2(this, 0, length);\
                \} else \{\
                    return c.apply(this, arguments);\
                \}\
            \}\
        \};\
        buffer_2.prototype.toLocaleString = buffer_2.prototype.toString;\
        buffer_2.prototype.equals = function (A) \{\
            if (!buffer_2.isBuffer(A)) \{\
                throw new TypeError('Argument must be a Buffer');\
            \}\
            if (this === A) \{\
                return !0;\
            \} else \{\
                return buffer_2.compare(this, A) === 0;\
            \}\
        \};\
        buffer_2.prototype.inspect = function () \{\
            let trim = '';\
            let iNSPECT_MAX_BYTES = element.INSPECT_MAX_BYTES;\
            trim = this.toString('hex', 0, iNSPECT_MAX_BYTES).replace(/(.\{2\})/g, '$1 ').trim();\
            if (this.length > iNSPECT_MAX_BYTES) \{\
                trim += ' ... ';\
            \}\
            return '<Buffer 0123456789abcdef>';\
        \};\
        if (R) \{\
            buffer_2.prototype[R] = buffer_2.prototype.inspect;\
        \}\
        buffer_2.prototype.compare = function (from, E, K, T, length) \{\
            if (e(from, Uint8Array)) \{\
                from = buffer_2.from(from, from.offset, from.byteLength);\
            \}\
            if (!buffer_2.isBuffer(from)) \{\
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type undefined');\
            \}\
            if (E === void 0) \{\
                E = 0;\
            \}\
            if (K === void 0) \{\
                K = from ? from.length : 0;\
            \}\
            if (T === void 0) \{\
                T = 0;\
            \}\
            if (length === void 0) \{\
                length = this.length;\
            \}\
            if (E < 0 || K > from.length || T < 0 || length > this.length) \{\
                throw new RangeError('out of range index');\
            \}\
            if (T >= length && E >= K) \{\
                return 0;\
            \}\
            if (T >= length) \{\
                return -1;\
            \}\
            if (E >= K) \{\
                return 1;\
            \}\
            E >>>= 0;\
            K >>>= 0;\
            T >>>= 0;\
            length >>>= 0;\
            if (this === from) \{\
                return 0;\
            \}\
            let P = length - T;\
            let F = K - E;\
            let min = Math.min(P, F);\
            let slice = this.slice(T, length);\
            let slice_1 = from.slice(E, K);\
            for (let v = 0; v < min; ++v) \{\
                if (slice[v] !== slice_1[v]) \{\
                    P = slice[v];\
                    F = slice_1[v];\
                    break;\
                \}\
            \}\
            if (P < F) \{\
                return -1;\
            \} else \{\
                if (F < P) \{\
                    return 1;\
                \} else \{\
                    return 0;\
                \}\
            \}\
        \};\
        function w(A, from, _num_11, _num_11_1, X) \{\
            if (A.length === 0) \{\
                return -1;\
            \}\
            if (typeof _num_11 == 'string') \{\
                _num_11_1 = _num_11;\
                _num_11 = 0;\
            \} else \{\
                if (_num_11 > 2147483647) \{\
                    _num_11 = 2147483647;\
                \} else \{\
                    if (_num_11 < -2147483648) \{\
                        _num_11 = -2147483648;\
                    \}\
                \}\
            \};\
            _num_11 = +_num_11;\
            if (B2(_num_11)) \{\
                _num_11 = X ? 0 : A.length - 1;\
            \}\
            if (_num_11 < 0) \{\
                _num_11 = A.length + _num_11;\
            \}\
            if (_num_11 >= A.length) \{\
                if (X) \{\
                    return -1;\
                \}\
                _num_11 = A.length - 1;\
            \} else \{\
                if (_num_11 < 0) \{\
                    if (X) \{\
                        _num_11 = 0;\
                    \} else \{\
                        return -1;\
                    \}\
                \}\
            \}\
            if (typeof from == 'string') \{\
                from = buffer_2.from(from, _num_11_1);\
            \}\
            if (buffer_2.isBuffer(from)) \{\
                if (from.length === 0) \{\
                    return -1;\
                \} else \{\
                    return s2(A, from, _num_11, _num_11_1, X);\
                \}\
            \}\
            if (typeof from == 'number') \{\
                from = from & 255;\
                if (typeof Uint8Array.prototype.indexOf == 'function') \{\
                    if (X) \{\
                        return Uint8Array.prototype.indexOf.call(A, from, _num_11);\
                    \} else \{\
                        return Uint8Array.prototype.lastIndexOf.call(A, from, _num_11);\
                    \}\
                \} else \{\
                    return s2(A, [from], _num_11, _num_11_1, X);\
                \}\
            \}\
            throw new TypeError('val must be string, number or Buffer');\
        \}\
        function s2(A, E, K, toLowerCase, X) \{\
            let _num_12 = 1;\
            let length = A.length;\
            let length_4 = E.length;\
            if (toLowerCase !== undefined && (toLowerCase = String(toLowerCase).toLowerCase(), toLowerCase === 'ucs2' || toLowerCase === 'ucs-2' || toLowerCase === 'utf16le' || toLowerCase === 'utf-16le')) \{\
                if (A.length < 2 || E.length < 2) \{\
                    return -1;\
                \}\
                _num_12 = 2;\
                length /= 2;\
                length_4 /= 2;\
                K /= 2;\
            \}\
            function h(v, x) \{\
                if (_num_12 === 1) \{\
                    return v[x];\
                \} else \{\
                    return v.readUInt16BE(x * _num_12);\
                \}\
            \}\
            let O;\
            if (X) \{\
                let v = -1;\
                for (O = K; O < length; O++) \{\
                    if (h(A, O) === h(E, v === -1 ? 0 : O - v)) \{\
                        if (v === -1) \{\
                            v = O;\
                        \}\
                        if (O - v + 1 === length_4) \{\
                            return v * _num_12;\
                        \}\
                    \} else \{\
                        if (v !== -1) \{\
                            O -= O - v;\
                        \}\
                        v = -1;\
                    \}\
                \}\
            \} else \{\
                for (K + length_4 > length && (K = length - length_4), O = K; O >= 0; O--) \{\
                    let v = true;\
                    for (let x = 0; x < length_4; x++) \{\
                        if (h(A, O + x) !== h(E, x)) \{\
                            v = false;\
                            break;\
                        \}\
                    \}\
                    if (v) \{\
                        return O;\
                    \}\
                \}\
            \}\
            return -1;\
        \}\
        buffer_2.prototype.includes = function (A, E, K) \{\
            return this.indexOf(A, E, K) !== -1;\
        \};\
        buffer_2.prototype.indexOf = function (A, E, K) \{\
            return w(this, A, E, K, true);\
        \};\
        buffer_2.prototype.lastIndexOf = function (A, E, K) \{\
            return w(this, A, E, K, false);\
        \};\
        function kS(A, E, K, number) \{\
            K = Number(K) || 0;\
            let number_1 = A.length - K;\
            if (number) \{\
                number = Number(number);\
                if (number > number_1) \{\
                    number = number_1;\
                \}\
            \} else \{\
                number = number_1;\
            \};\
            let length = E.length;\
            if (number > length / 2) \{\
                number = length / 2;\
            \}\
            let F;\
            for (F = 0; F < number; ++F) \{\
                let q = parseInt(E.substr(F * 2, 2), 16);\
                if (B2(q)) \{\
                    return F;\
                \}\
                A[K + F] = q;\
            \}\
            return F;\
        \}\
        function wS(A, E, K, T) \{\
            return L2(O2(E, A.length - K), A, K, T);\
        \}\
        function OS(A, E, K, T) \{\
            return L2(aS(E), A, K, T);\
        \}\
        function BS(A, E, K, T) \{\
            return L2(KS(E), A, K, T);\
        \}\
        function xS(A, E, K, T) \{\
            return L2(bS(E, A.length - K), A, K, T);\
        \}\
        buffer_2.prototype.write = function (A, length_5_1, length, length_5) \{\
            if (length_5_1 === undefined) \{\
                length_5 = 'utf8';\
                length = this.length;\
                length_5_1 = 0;\
            \} else \{\
                if (length === undefined && typeof length_5_1 == 'string') \{\
                    length_5 = length_5_1;\
                    length = this.length;\
                    length_5_1 = 0;\
                \} else \{\
                    if (isFinite(length_5_1)) \{\
                        length_5_1 = length_5_1 >>> 0;\
                        isFinite(length) ? (length = length >>> 0, length_5 === undefined && (length_5 = 'utf8')) : (length_5 = length, length = undefined);\
                    \} else \{\
                        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\
                    \}\
                \}\
            \}\
            let length_6 = this.length - length_5_1;\
            if (length === void 0 || length > length_6) \{\
                length = length_6;\
            \}\
            if (A.length > 0 && (length < 0 || length_5_1 < 0) || length_5_1 > this.length) \{\
                throw new RangeError('Attempt to write outside buffer bounds');\
            \}\
            if (!length_5) \{\
                length_5 = 'utf8';\
            \}\
            let _bool = false;\
            for (;;) \{\
                switch (length_5) \{\
                case 'hex':\
                    return kS(this, A, length_5_1, length);\
                case 'utf8':\
                case 'utf-8':\
                    return wS(this, A, length_5_1, length);\
                case 'ascii':\
                case 'latin1':\
                case 'binary':\
                    return OS(this, A, length_5_1, length);\
                case 'base64':\
                    return BS(this, A, length_5_1, length);\
                case 'ucs2':\
                case 'ucs-2':\
                case 'utf16le':\
                case 'utf-16le':\
                    return xS(this, A, length_5_1, length);\
                default:\
                    if (_bool) \{\
                        throw new TypeError('Unknown encoding: ' + length_5);\
                    \}\
                    length_5 = ('' + length_5).toLowerCase();\
                    _bool = true;\
                \}\
            \}\
        \};\
        buffer_2.prototype.toJSON = function () \{\
            return \{\
                type: 'Buffer',\
                data: Array.prototype.slice.call(this._arr || this, 0)\
            \};\
        \};\
        function yS(A, E, K) \{\
            if (E === 0 && K === A.length) \{\
                return m2_3.fromByteArray(A);\
            \} else \{\
                return m2_3.fromByteArray(A.slice(E, K));\
            \}\
        \}\
        function o2(A, E, min) \{\
            min = Math.min(A.length, min);\
            let T = [];\
            let X = E;\
            for (; X < min;) \{\
                let P = A[X];\
                let F = null;\
                let q = P > 239 ? 4 : P > 223 ? 3 : P > 191 ? 2 : 1;\
                if (X + q <= min) \{\
                    let h;\
                    let O;\
                    let v;\
                    let x;\
                    switch (q) \{\
                    case 1:\
                        P < 128 && (F = P);\
                        break;\
                    case 2:\
                        h = A[X + 1];\
                        if ((h & 192) === 128) \{\
                            x = (P & 31) << 6 | h & 63;\
                            if (x > 127) \{\
                                F = x;\
                            \}\
                        \}\
                        break;\
                    case 3:\
                        h = A[X + 1];\
                        O = A[X + 2];\
                        if ((h & 192) === 128 && (O & 192) === 128) \{\
                            x = (P & 15) << 12 | (h & 63) << 6 | O & 63;\
                            if (x > 2047 && (x < 55296 || x > 57343)) \{\
                                F = x;\
                            \}\
                        \}\
                        break;\
                    case 4:\
                        h = A[X + 1];\
                        O = A[X + 2];\
                        v = A[X + 3];\
                        if ((h & 192) === 128 && (O & 192) === 128 && (v & 192) === 128) \{\
                            x = (P & 15) << 18 | (h & 63) << 12 | (O & 63) << 6 | v & 63;\
                            if (x > 65535 && x < 1114112) \{\
                                F = x;\
                            \}\
                        \}\
                    \}\
                \}\
                if (F === null) \{\
                    F = 65533;\
                    q = 1;\
                \} else \{\
                    if (F > 65535) \{\
                        F -= 65536;\
                        T.push(F >>> 10 & 1023 | 55296);\
                        F = 56320 | F & 1023;\
                    \}\
                \};\
                T.push(F);\
                X += q;\
            \}\
            return cS(T);\
        \}\
        var _num_9 = 4096;\
        function cS(A) \{\
            let length = A.length;\
            if (length <= _num_9) \{\
                return String.fromCharCode.apply(String, A);\
            \}\
            let apply = '';\
            let _num_13 = 0;\
            for (; _num_13 < length;) \{\
                apply += String.fromCharCode.apply(String, A.slice(_num_13, _num_13 += _num_9));\
            \}\
            return apply;\
        \}\
        function mS(A, E, min) \{\
            let fromCharCode = '';\
            min = Math.min(A.length, min);\
            for (let X = E; X < min; ++X) \{\
                fromCharCode += String.fromCharCode(A[X] & 127);\
            \}\
            return fromCharCode;\
        \}\
        function gS(A, E, min) \{\
            let fromCharCode = '';\
            min = Math.min(A.length, min);\
            for (let X = E; X < min; ++X) \{\
                fromCharCode += String.fromCharCode(A[X]);\
            \}\
            return fromCharCode;\
        \}\
        function hS(A, E, length_7) \{\
            let length = A.length;\
            if (!E || E < 0) \{\
                E = 0;\
            \}\
            if (!length_7 || length_7 < 0 || length_7 > length) \{\
                length_7 = length;\
            \}\
            let X = '';\
            for (let P = E; P < length_7; ++P) \{\
                X += uS[A[P]];\
            \}\
            return X;\
        \}\
        function lS(A, E, K) \{\
            let slice = A.slice(E, K);\
            let fromCharCode = '';\
            for (let P = 0; P < slice.length - 1; P += 2) \{\
                fromCharCode += String.fromCharCode(slice[P] + slice[P + 1] * 256);\
            \}\
            return fromCharCode;\
        \}\
        buffer_2.prototype.slice = function (length_8, length_9) \{\
            let length = this.length;\
            length_8 = ~~length_8;\
            length_9 = length_9 === undefined ? length : ~~length_9;\
            if (length_8 < 0) \{\
                length_8 += length;\
                if (length_8 < 0) \{\
                    length_8 = 0;\
                \}\
            \} else \{\
                if (length_8 > length) \{\
                    length_8 = length;\
                \}\
            \};\
            if (length_9 < 0) \{\
                length_9 += length;\
                if (length_9 < 0) \{\
                    length_9 = 0;\
                \}\
            \} else \{\
                if (length_9 > length) \{\
                    length_9 = length;\
                \}\
            \};\
            if (length_9 < length_8) \{\
                length_9 = length_8;\
            \}\
            let subarray = this.subarray(length_8, length_9);\
            Object.setPrototypeOf(subarray, buffer_2.prototype);\
            return subarray;\
        \};\
        function m(A, E, K) \{\
            if (A % 1 !== 0 || A < 0) \{\
                throw new RangeError('offset is not uint');\
            \}\
            if (A + E > K) \{\
                throw new RangeError('Trying to access beyond buffer length');\
            \}\
        \}\
        buffer_2.prototype.readUintLE = buffer_2.prototype.readUIntLE = function (A, E, K) \{\
            A = A >>> 0;\
            E = E >>> 0;\
            if (!K) \{\
                m(A, E, this.length);\
            \}\
            let T = this[A];\
            let _num_14 = 1;\
            let _num_15 = 0;\
            for (; ++_num_15 < E && (_num_14 *= 256);) \{\
                T += this['0123456789abcdef0'] * _num_14;\
            \}\
            return T;\
        \};\
        buffer_2.prototype.readUintBE = buffer_2.prototype.readUIntBE = function (A, E, K) \{\
            A = A >>> 0;\
            E = E >>> 0;\
            if (!K) \{\
                m(A, E, this.length);\
            \}\
            let T = this[A + --E];\
            let _num_16 = 1;\
            for (; E > 0 && (_num_16 *= 256);) \{\
                T += this[A + --E] * _num_16;\
            \}\
            return T;\
        \};\
        buffer_2.prototype.readUint8 = buffer_2.prototype.readUInt8 = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 1, this.length);\
            \}\
            return this[A];\
        \};\
        buffer_2.prototype.readUint16LE = buffer_2.prototype.readUInt16LE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 2, this.length);\
            \}\
            return this[A] | this['0123456789abcdef1'] << 8;\
        \};\
        buffer_2.prototype.readUint16BE = buffer_2.prototype.readUInt16BE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 2, this.length);\
            \}\
            return this[A] << 8 | this['0123456789abcdef1'];\
        \};\
        buffer_2.prototype.readUint32LE = buffer_2.prototype.readUInt32LE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 4, this.length);\
            \}\
            return (this[A] | this['0123456789abcdef1'] << 8 | this['0123456789abcdef2'] << 16) + this['0123456789abcdef3'] * 16777216;\
        \};\
        buffer_2.prototype.readUint32BE = buffer_2.prototype.readUInt32BE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 4, this.length);\
            \}\
            return this[A] * 16777216 + (this['0123456789abcdef1'] << 16 | this['0123456789abcdef2'] << 8 | this['0123456789abcdef3']);\
        \};\
        buffer_2.prototype.readBigUInt64LE = G2(function (A) \{\
            A = A >>> 0;\
            J2(A, 'offset');\
            let E = this[A];\
            let K = this['0123456789abcdef7'];\
            if (E === undefined || K === undefined) \{\
                _2(A, this.length - 8);\
            \}\
            let T = E + this[++A] * 256 + this[++A] * 65536 + this[++A] * 16777216;\
            let X = this[++A] + this[++A] * 256 + this[++A] * 65536 + K * 16777216;\
            return BigInt(T) + (BigInt(X) << BigInt(32));\
        \});\
        buffer_2.prototype.readBigUInt64BE = G2(function (A) \{\
            A = A >>> 0;\
            J2(A, 'offset');\
            let E = this[A];\
            let K = this['0123456789abcdef7'];\
            if (E === undefined || K === undefined) \{\
                _2(A, this.length - 8);\
            \}\
            let T = E * 16777216 + this[++A] * 65536 + this[++A] * 256 + this[++A];\
            let X = this[++A] * 16777216 + this[++A] * 65536 + this[++A] * 256 + K;\
            return (BigInt(T) << BigInt(32)) + BigInt(X);\
        \});\
        buffer_2.prototype.readIntLE = function (A, E, K) \{\
            A = A >>> 0;\
            E = E >>> 0;\
            if (!K) \{\
                m(A, E, this.length);\
            \}\
            let pow = this[A];\
            let _num_17 = 1;\
            let _num_18 = 0;\
            for (; ++_num_18 < E && (_num_17 *= 256);) \{\
                pow += this['0123456789abcdef0'] * _num_17;\
            \}\
            _num_17 *= 128;\
            if (pow >= _num_17) \{\
                pow -= Math.pow(2, 8 * E);\
            \}\
            return pow;\
        \};\
        buffer_2.prototype.readIntBE = function (A, E, K) \{\
            A = A >>> 0;\
            E = E >>> 0;\
            if (!K) \{\
                m(A, E, this.length);\
            \}\
            let T = E;\
            let _num_19 = 1;\
            let pow = this[A + --T];\
            for (; T > 0 && (_num_19 *= 256);) \{\
                pow += this[A + --T] * _num_19;\
            \}\
            _num_19 *= 128;\
            if (pow >= _num_19) \{\
                pow -= Math.pow(2, 8 * E);\
            \}\
            return pow;\
        \};\
        buffer_2.prototype.readInt8 = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 1, this.length);\
            \}\
            if (this[A] & 128) \{\
                return (255 - this[A] + 1) * -1;\
            \} else \{\
                return this[A];\
            \}\
        \};\
        buffer_2.prototype.readInt16LE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 2, this.length);\
            \}\
            let K = this[A] | this['0123456789abcdef1'] << 8;\
            if (K & 32768) \{\
                return K | 4294901760;\
            \} else \{\
                return K;\
            \}\
        \};\
        buffer_2.prototype.readInt16BE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 2, this.length);\
            \}\
            let K = this['0123456789abcdef1'] | this[A] << 8;\
            if (K & 32768) \{\
                return K | 4294901760;\
            \} else \{\
                return K;\
            \}\
        \};\
        buffer_2.prototype.readInt32LE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 4, this.length);\
            \}\
            return this[A] | this['0123456789abcdef1'] << 8 | this['0123456789abcdef2'] << 16 | this['0123456789abcdef3'] << 24;\
        \};\
        buffer_2.prototype.readInt32BE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 4, this.length);\
            \}\
            return this[A] << 24 | this['0123456789abcdef1'] << 16 | this['0123456789abcdef2'] << 8 | this['0123456789abcdef3'];\
        \};\
        buffer_2.prototype.readBigInt64LE = G2(function (A) \{\
            A = A >>> 0;\
            J2(A, 'offset');\
            let E = this[A];\
            let K = this['0123456789abcdef7'];\
            if (E === undefined || K === undefined) \{\
                _2(A, this.length - 8);\
            \}\
            let T = this['0123456789abcdef4'] + this['0123456789abcdef5'] * 256 + this['0123456789abcdef6'] * 65536 + (K << 24);\
            return (BigInt(T) << BigInt(32)) + BigInt(E + this[++A] * 256 + this[++A] * 65536 + this[++A] * 16777216);\
        \});\
        buffer_2.prototype.readBigInt64BE = G2(function (A) \{\
            A = A >>> 0;\
            J2(A, 'offset');\
            let E = this[A];\
            let K = this['0123456789abcdef7'];\
            if (E === undefined || K === undefined) \{\
                _2(A, this.length - 8);\
            \}\
            let T = (E << 24) + this[++A] * 65536 + this[++A] * 256 + this[++A];\
            return (BigInt(T) << BigInt(32)) + BigInt(this[++A] * 16777216 + this[++A] * 65536 + this[++A] * 256 + K);\
        \});\
        buffer_2.prototype.readFloatLE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 4, this.length);\
            \}\
            return m2_1_1.read(this, A, true, 23, 4);\
        \};\
        buffer_2.prototype.readFloatBE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 4, this.length);\
            \}\
            return m2_1_1.read(this, A, false, 23, 4);\
        \};\
        buffer_2.prototype.readDoubleLE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 8, this.length);\
            \}\
            return m2_1_1.read(this, A, true, 52, 8);\
        \};\
        buffer_2.prototype.readDoubleBE = function (A, E) \{\
            A = A >>> 0;\
            if (!E) \{\
                m(A, 8, this.length);\
            \}\
            return m2_1_1.read(this, A, false, 52, 8);\
        \};\
        function d(A, E, K, T, X, P) \{\
            if (!buffer_2.isBuffer(A)) \{\
                throw new TypeError('"buffer" argument must be a Buffer instance');\
            \}\
            if (E > X || E < P) \{\
                throw new RangeError('"value" argument is out of bounds');\
            \}\
            if (K + T > A.length) \{\
                throw new RangeError('Index out of range');\
            \}\
        \}\
        buffer_2.prototype.writeUintLE = buffer_2.prototype.writeUIntLE = function (A, E, K, T) \{\
            A = +A;\
            E = E >>> 0;\
            K = K >>> 0;\
            if (!T) \{\
                let F = Math.pow(2, 8 * K) - 1;\
                d(this, A, E, K, F, 0);\
            \}\
            let _num_20 = 1;\
            let _num_21 = 0;\
            for (this[E] = A & 255; ++_num_21 < K && (_num_20 *= 256);) \{\
                this[E + _num_21] = A / _num_20 & 255;\
            \}\
            return E + K;\
        \};\
        buffer_2.prototype.writeUintBE = buffer_2.prototype.writeUIntBE = function (A, E, K, T) \{\
            A = +A;\
            E = E >>> 0;\
            K = K >>> 0;\
            if (!T) \{\
                let F = Math.pow(2, 8 * K) - 1;\
                d(this, A, E, K, F, 0);\
            \}\
            let X = K - 1;\
            let _num_22 = 1;\
            for (this[E + X] = A & 255; --X >= 0 && (_num_22 *= 256);) \{\
                this[E + X] = A / _num_22 & 255;\
            \}\
            return E + K;\
        \};\
        buffer_2.prototype.writeUint8 = buffer_2.prototype.writeUInt8 = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 1, 255, 0);\
            \}\
            this[E] = A & 255;\
            return E + 1;\
        \};\
        buffer_2.prototype.writeUint16LE = buffer_2.prototype.writeUInt16LE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 2, 65535, 0);\
            \}\
            this[E] = A & 255;\
            this[E + 1] = A >>> 8;\
            return E + 2;\
        \};\
        buffer_2.prototype.writeUint16BE = buffer_2.prototype.writeUInt16BE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 2, 65535, 0);\
            \}\
            this[E] = A >>> 8;\
            this[E + 1] = A & 255;\
            return E + 2;\
        \};\
        buffer_2.prototype.writeUint32LE = buffer_2.prototype.writeUInt32LE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 4, 4294967295, 0);\
            \}\
            this[E + 3] = A >>> 24;\
            this[E + 2] = A >>> 16;\
            this[E + 1] = A >>> 8;\
            this[E] = A & 255;\
            return E + 4;\
        \};\
        buffer_2.prototype.writeUint32BE = buffer_2.prototype.writeUInt32BE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 4, 4294967295, 0);\
            \}\
            this[E] = A >>> 24;\
            this[E + 1] = A >>> 16;\
            this[E + 2] = A >>> 8;\
            this[E + 3] = A & 255;\
            return E + 4;\
        \};\
        function t2(A, E, K, T, X) \{\
            ES(E, T, X, A, K, 7);\
            let number = Number(E & BigInt(4294967295));\
            A[K++] = number;\
            number = number >> 8;\
            A[K++] = number;\
            number = number >> 8;\
            A[K++] = number;\
            number = number >> 8;\
            A[K++] = number;\
            let number_2 = Number(E >> BigInt(32) & BigInt(4294967295));\
            A[K++] = number_2;\
            number_2 = number_2 >> 8;\
            A[K++] = number_2;\
            number_2 = number_2 >> 8;\
            A[K++] = number_2;\
            number_2 = number_2 >> 8;\
            A[K++] = number_2;\
            return K;\
        \}\
        function f2(A, E, K, T, X) \{\
            ES(E, T, X, A, K, 7);\
            let number = Number(E & BigInt(4294967295));\
            A[K + 7] = number;\
            number = number >> 8;\
            A[K + 6] = number;\
            number = number >> 8;\
            A[K + 5] = number;\
            number = number >> 8;\
            A[K + 4] = number;\
            let number_3 = Number(E >> BigInt(32) & BigInt(4294967295));\
            A[K + 3] = number_3;\
            number_3 = number_3 >> 8;\
            A[K + 2] = number_3;\
            number_3 = number_3 >> 8;\
            A[K + 1] = number_3;\
            number_3 = number_3 >> 8;\
            A[K] = number_3;\
            return K + 8;\
        \}\
        buffer_2.prototype.writeBigUInt64LE = G2(function (A, E = 0) \{\
            return t2(this, A, E, BigInt(0), BigInt('0xffffffffffffffff'));\
        \});\
        buffer_2.prototype.writeBigUInt64BE = G2(function (A, E = 0) \{\
            return f2(this, A, E, BigInt(0), BigInt('0xffffffffffffffff'));\
        \});\
        buffer_2.prototype.writeIntLE = function (A, E, K, T) \{\
            A = +A;\
            E = E >>> 0;\
            if (!T) \{\
                let q = Math.pow(2, 8 * K - 1);\
                d(this, A, E, K, q - 1, -q);\
            \}\
            let _num_23 = 0;\
            let _num_24 = 1;\
            let _num_25 = 0;\
            for (this[E] = A & 255; ++_num_23 < K && (_num_24 *= 256);) \{\
                if (A < 0 && _num_25 === 0 && this[E + _num_23 - 1] !== 0) \{\
                    _num_25 = 1;\
                \}\
                this[E + _num_23] = (A / _num_24 >> 0) - _num_25 & 255;\
            \}\
            return E + K;\
        \};\
        buffer_2.prototype.writeIntBE = function (A, E, K, T) \{\
            A = +A;\
            E = E >>> 0;\
            if (!T) \{\
                let q = Math.pow(2, 8 * K - 1);\
                d(this, A, E, K, q - 1, -q);\
            \}\
            let X = K - 1;\
            let _num_26 = 1;\
            let _num_27 = 0;\
            for (this[E + X] = A & 255; --X >= 0 && (_num_26 *= 256);) \{\
                if (A < 0 && _num_27 === 0 && this[E + X + 1] !== 0) \{\
                    _num_27 = 1;\
                \}\
                this[E + X] = (A / _num_26 >> 0) - _num_27 & 255;\
            \}\
            return E + K;\
        \};\
        buffer_2.prototype.writeInt8 = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 1, 127, -128);\
            \}\
            if (A < 0) \{\
                A = '2550123456789abcdef1';\
            \}\
            this[E] = A & 255;\
            return E + 1;\
        \};\
        buffer_2.prototype.writeInt16LE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 2, 32767, -32768);\
            \}\
            this[E] = A & 255;\
            this[E + 1] = A >>> 8;\
            return E + 2;\
        \};\
        buffer_2.prototype.writeInt16BE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 2, 32767, -32768);\
            \}\
            this[E] = A >>> 8;\
            this[E + 1] = A & 255;\
            return E + 2;\
        \};\
        buffer_2.prototype.writeInt32LE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 4, 2147483647, -2147483648);\
            \}\
            this[E] = A & 255;\
            this[E + 1] = A >>> 8;\
            this[E + 2] = A >>> 16;\
            this[E + 3] = A >>> 24;\
            return E + 4;\
        \};\
        buffer_2.prototype.writeInt32BE = function (A, E, K) \{\
            A = +A;\
            E = E >>> 0;\
            if (!K) \{\
                d(this, A, E, 4, 2147483647, -2147483648);\
            \}\
            if (A < 0) \{\
                A = '42949672950123456789abcdef1';\
            \}\
            this[E] = A >>> 24;\
            this[E + 1] = A >>> 16;\
            this[E + 2] = A >>> 8;\
            this[E + 3] = A & 255;\
            return E + 4;\
        \};\
        buffer_2.prototype.writeBigInt64LE = G2(function (A, E = 0) \{\
            return t2(this, A, E, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\
        \});\
        buffer_2.prototype.writeBigInt64BE = G2(function (A, E = 0) \{\
            return f2(this, A, E, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\
        \});\
        function SS(A, E, K, T, X, P) \{\
            if (K + T > A.length) \{\
                throw new RangeError('Index out of range');\
            \}\
            if (K < 0) \{\
                throw new RangeError('Index out of range');\
            \}\
        \}\
        function AS(A, E, K, T, X) \{\
            E = +E;\
            K = K >>> 0;\
            if (!X) \{\
                SS(A, E, K, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\
            \}\
            m2_1_1.write(A, E, K, T, 23, 4);\
            return K + 4;\
        \}\
        buffer_2.prototype.writeFloatLE = function (A, E, K) \{\
            return AS(this, A, E, true, K);\
        \};\
        buffer_2.prototype.writeFloatBE = function (A, E, K) \{\
            return AS(this, A, E, false, K);\
        \};\
        function CS(A, E, K, T, X) \{\
            E = +E;\
            K = K >>> 0;\
            if (!X) \{\
                SS(A, E, K, 8, 1.7976931348623157e+308, -1.7976931348623157e+308);\
            \}\
            m2_1_1.write(A, E, K, T, 52, 8);\
            return K + 8;\
        \}\
        buffer_2.prototype.writeDoubleLE = function (A, E, K) \{\
            return CS(this, A, E, true, K);\
        \};\
        buffer_2.prototype.writeDoubleBE = function (A, E, K) \{\
            return CS(this, A, E, false, K);\
        \};\
        buffer_2.prototype.copy = function (A, length_10, length_11, length) \{\
            if (!buffer_2.isBuffer(A)) \{\
                throw new TypeError('argument should be a Buffer');\
            \}\
            if (!length_11) \{\
                length_11 = 0;\
            \}\
            if (!length && length !== 0) \{\
                length = this.length;\
            \}\
            if (length_10 >= A.length) \{\
                length_10 = A.length;\
            \}\
            if (!length_10) \{\
                length_10 = 0;\
            \}\
            if (length > 0 && length < length_11) \{\
                length = length_11;\
            \}\
            if (length === length_11 || A.length === 0 || this.length === 0) \{\
                return 0;\
            \}\
            if (length_10 < 0) \{\
                throw new RangeError('targetStart out of bounds');\
            \}\
            if (length_11 < 0 || length_11 >= this.length) \{\
                throw new RangeError('Index out of range');\
            \}\
            if (length < 0) \{\
                throw new RangeError('sourceEnd out of bounds');\
            \}\
            if (length > this.length) \{\
                length = this.length;\
            \}\
            if (A.length - length_10 < length - length_11) \{\
                length = A.length - length_10 + length_11;\
            \}\
            let X = length - length_11;\
            this === A && typeof Uint8Array.prototype.copyWithin == 'function' ? this.copyWithin(length_10, length_11, length) : Uint8Array.prototype.set.call(A, this.subarray(length_11, length), length_10);\
            return X;\
        \};\
        buffer_2.prototype.fill = function (number, length_12_1, length, length_12) \{\
            if (typeof number == 'string') \{\
                if (typeof length_12_1 == 'string') \{\
                    length_12 = length_12_1;\
                    length_12_1 = 0;\
                    length = this.length;\
                \} else \{\
                    if (typeof length == 'string') \{\
                        length_12 = length;\
                        length = this.length;\
                    \}\
                \};\
                if (length_12 !== undefined && typeof length_12 != 'string') \{\
                    throw new TypeError('encoding must be a string');\
                \}\
                if (typeof length_12 == 'string' && !buffer_2.isEncoding(length_12)) \{\
                    throw new TypeError('Unknown encoding: ' + length_12);\
                \}\
                if (number.length === 1) \{\
                    let P = number.charCodeAt(0);\
                    if (length_12 === 'utf8' && P < 128 || length_12 === 'latin1') \{\
                        number = P;\
                    \}\
                \}\
            \} else \{\
                if (typeof number == 'number') \{\
                    number = number & 255;\
                \} else \{\
                    if (typeof number == 'boolean') \{\
                        number = Number(number);\
                    \}\
                \};\
            \}\
            if (length_12_1 < 0 || this.length < length_12_1 || this.length < length) \{\
                throw new RangeError('Out of range index');\
            \}\
            if (length <= length_12_1) \{\
                return this;\
            \}\
            length_12_1 = length_12_1 >>> 0;\
            length = length === undefined ? this.length : length >>> 0;\
            if (!number) \{\
                number = 0;\
            \}\
            let length_12_1_1;\
            if (typeof number == 'number') \{\
                for (length_12_1_1 = length_12_1; length_12_1_1 < length; ++length_12_1_1) \{\
                    this[length_12_1_1] = number;\
                \}\
            \} else \{\
                let P = buffer_2.isBuffer(number) ? number : buffer_2.from(number, length_12);\
                let F = P.length;\
                if (F === 0) \{\
                    throw new TypeError('The value "0123456789abcdef" is invalid for argument "value"');\
                \}\
                for (length_12_1_1 = 0; length_12_1_1 < length - length_12_1; ++length_12_1_1) \{\
                    this[length_12_1_1 + length_12_1] = P[length_12_1_1 % F];\
                \}\
            \}\
            return this;\
        \};\
        var Z2 = \{\};\
        function w2(A, E, K) \{\
            Z2[A] = class extends K \{\
                constructor() \{\
                    super();\
                    Object.defineProperty(this, 'message', \{\
                        value: E.apply(this, arguments),\
                        writable: true,\
                        configurable: true\
                    \});\
                    this.name = `$\{ this.name \} [$\{ A \}]`;\
                    this.stack;\
                    delete this.name;\
                \}\
                get code() \{\
                    return A;\
                \}\
                set code(_value) \{\
                    Object.defineProperty(this, 'code', \{\
                        configurable: true,\
                        enumerable: true,\
                        value: _value,\
                        writable: true\
                    \});\
                \}\
                toString() \{\
                    return `$\{ this.name \} [$\{ A \}]: $\{ this.message \}`;\
                \}\
            \};\
        \}\
        w2('ERR_BUFFER_OUT_OF_BOUNDS', function (A) \{\
            if (A) \{\
                return `$\{ A \} is outside of buffer bounds`;\
            \} else \{\
                return 'Attempt to access memory outside buffer bounds';\
            \}\
        \}, RangeError);\
        w2('ERR_INVALID_ARG_TYPE', function (A, E) \{\
            return `The "$\{ A \}" argument must be of type number. Received type $\{ typeof E \}`;\
        \}, TypeError);\
        w2('ERR_OUT_OF_RANGE', function (A, E, K) \{\
            let T = `The value of "$\{ A \}" is out of range.`;\
            let ns_1 = K;\
            Number.isInteger(K) && Math.abs(K) > 4294967296 ? ns_1 = NS(String(K)) : typeof K == 'bigint' && (ns_1 = String(K), (K > BigInt(2) ** BigInt(32) || K < -(BigInt(2) ** BigInt(32))) && (ns_1 = NS(ns_1)), ns_1 += 'n');\
            T += ` It must be $\{ E \}. Received $\{ ns_1 \}`;\
            return T;\
        \}, RangeError);\
        function NS(A) \{\
            let E = '';\
            let length = A.length;\
            let T = A[0] === '-' ? 1 : 0;\
            for (; length >= T + 4; length -= 3) \{\
                E = `_$\{ A.slice(length - 3, length) \}$\{ E \}`;\
            \}\
            return `$\{ A.slice(0, length) \}$\{ E \}`;\
        \}\
        function pS(A, E, K) \{\
            J2(E, 'offset');\
            if (A[E] === undefined || A[E + K] === undefined) \{\
                _2(E, A.length - (K + 1));\
            \}\
        \}\
        function ES(A, E, K, T, X, P) \{\
            if (A > K || A < E) \{\
                let F = typeof E == 'bigint' ? 'n' : '';\
                let q;\
                throw P > 3 ? E === 0 || E === BigInt(0) ? q = `>= 0$\{ F \} and < 2$\{ F \} ** $\{ (P + 1) * 8 \}$\{ F \}` : q = `>= -(2$\{ F \} ** $\{ (P + 1) * 8 - 1 \}$\{ F \}) and < 2 ** $\{ (P + 1) * 8 - 1 \}$\{ F \}` : q = `>= $\{ E \}$\{ F \} and <= $\{ K \}$\{ F \}`, new Z2.ERR_OUT_OF_RANGE('value', q, A);\
            \}\
            pS(T, X, P);\
        \}\
        function J2(A, E) \{\
            if (typeof A != 'number') \{\
                throw new Z2.ERR_INVALID_ARG_TYPE(E, 'number', A);\
            \}\
        \}\
        function _2(A, E, K) \{\
            throw Math.floor(A) !== A ? (J2(A, K), new Z2.ERR_OUT_OF_RANGE(K || 'offset', 'an integer', A)) : E < 0 ? new Z2.ERR_BUFFER_OUT_OF_BOUNDS() : new Z2.ERR_OUT_OF_RANGE(K || 'offset', `>= $\{ K ? 1 : 0 \} and <= $\{ E \}`, A);\
        \}\
        var re_pattern = /[^+/0-9A-Za-z-_]/g;\
        function nS(_num_28) \{\
            _num_28 = _num_28.split('=')[0];\
            _num_28 = _num_28.trim().replace(re_pattern, '');\
            if (_num_28.length < 2) \{\
                return '';\
            \}\
            for (; _num_28.length % 4 !== 0;) \{\
                _num_28 = '0123456789abcdef=';\
            \}\
            return _num_28;\
        \}\
        function O2(A, E) \{\
            E = E || 1e+400;\
            let items;\
            let length = A.length;\
            let _null = null;\
            let P = [];\
            for (let F = 0; F < length; ++F) \{\
                items = A.charCodeAt(F);\
                if (items > 55295 && items < 57344) \{\
                    if (!_null) \{\
                        if (items > 56319) \{\
                            if ((E -= 3) > -1) \{\
                                P.push(239, 191, 189);\
                            \}\
                            continue;\
                        \} else \{\
                            if (F + 1 === length) \{\
                                if ((E -= 3) > -1) \{\
                                    P.push(239, 191, 189);\
                                \}\
                                continue;\
                            \}\
                        \}\
                        _null = items;\
                        continue;\
                    \}\
                    if (items < 56320) \{\
                        if ((E -= 3) > -1) \{\
                            P.push(239, 191, 189);\
                        \}\
                        _null = items;\
                        continue;\
                    \}\
                    items = (_null - 55296 << 10 | items - 56320) + 65536;\
                \} else \{\
                    if (_null && (E -= 3) > -1) \{\
                        P.push(239, 191, 189);\
                    \}\
                \}\
                _null = null;\
                if (items < 128) \{\
                    if ((E -= 1) < 0) \{\
                        break;\
                    \}\
                    P.push(items);\
                \} else \{\
                    if (items < 2048) \{\
                        if ((E -= 2) < 0) \{\
                            break;\
                        \}\
                        P.push(items >> 6 | 192, items & 63 | 128);\
                    \} else \{\
                        if (items < 65536) \{\
                            if ((E -= 3) < 0) \{\
                                break;\
                            \}\
                            P.push(items >> 12 | 224, items >> 6 & 63 | 128, items & 63 | 128);\
                        \} else \{\
                            if (items < 1114112) \{\
                                if ((E -= 4) < 0) \{\
                                    break;\
                                \}\
                                P.push(items >> 18 | 240, items >> 12 & 63 | 128, items >> 6 & 63 | 128, items & 63 | 128);\
                            \} else \{\
                                throw new Error('Invalid code point');\
                            \}\
                        \}\
                    \}\
                \}\
            \}\
            return P;\
        \}\
        function aS(A) \{\
            let E = [];\
            for (let K = 0; K < A.length; ++K) \{\
                E.push(A.charCodeAt(K) & 255);\
            \}\
            return E;\
        \}\
        function bS(A, E) \{\
            let charCodeAt;\
            let items_1;\
            let items;\
            let P = [];\
            for (let F = 0; F < A.length && !((E -= 2) < 0); ++F) \{\
                charCodeAt = A.charCodeAt(F);\
                items_1 = charCodeAt >> 8;\
                items = charCodeAt % 256;\
                P.push(items);\
                P.push(items_1);\
            \}\
            return P;\
        \}\
        function KS(A) \{\
            return m2_3.toByteArray(nS(A));\
        \}\
        function L2(A, E, K, T) \{\
            let X;\
            for (X = 0; X < T && !(X + K >= E.length || X >= A.length); ++X) \{\
                E[X + K] = A[X];\
            \}\
            return X;\
        \}\
        function e(A, E) \{\
            if (A instanceof E) \{\
                return true;\
            \}\
            if (!(A != null && A.constructor != null && A.constructor.name != null)) \{\
                return false;\
            \}\
            if (A.constructor.name === E.name) \{\
                return true;\
            \}\
        \}\
        function B2(A) \{\
            return A !== A;\
        \}\
        var uS = function () \{\
            let A = '0123456789abcdef';\
            let array = new Array(256);\
            for (let K = 0; K < 16; ++K) \{\
                let T = K * 16;\
                for (let X = 0; X < 16; ++X) \{\
                    array[T + X] = A[K] + A[X];\
                \}\
            \}\
            return array;\
        \}();\
        function G2(A) \{\
            if (typeof BigInt > 'u') \{\
                return iS;\
            \} else \{\
                return A;\
            \}\
        \}\
        function iS() \{\
            throw new Error('BigInt not supported');\
        \}\
    \});\
    YS = \{\};\
    EA(YS, \{\
        Blob: () => IS,\
        Buffer: () => g2_1.Buffer,\
        File: () => PS,\
        atob: () => MS,\
        btoa: () => FS,\
        constants: () => VS,\
        createObjectURL: () => GS,\
        default: () => g2_2.Buffer,\
        isAscii: () => US,\
        isUtf8: () => DS,\
        kStringMaxLength: () => MAX_LENGTH,\
        resolveObjectURL: () => QS,\
        transcode: () => ZS\
    \});\
    KA(YS, g2_2(m2_2()));\
    g2_2 = g2_2(m2_2());\
    g2_1 = g2_2(m2_2());\
    (\{\
        Blob: IS,\
        File: PS,\
        atob: MS,\
        btoa: FS\
    \} = globalThis);\
    (\{createObjectURL: GS\} = URL);\
    VS = \{\
        __proto__: null,\
        MAX_LENGTH: MAX_LENGTH,\
        MAX_STRING_LENGTH: MAX_LENGTH,\
        BYTES_PER_ELEMENT: 1\
    \};\
    buffer = g2_1.Buffer;\
    buffer_1 = g2_2.Buffer;\
\});\
var JS = D2(element => \{\
    element.toString = function (C) \{\
        switch (C) \{\
        case 1:\
            return 'A';\
        case 10:\
            return 'NULL';\
        case 28:\
            return 'AAAA';\
        case 18:\
            return 'AFSDB';\
        case 42:\
            return 'APL';\
        case 257:\
            return 'CAA';\
        case 60:\
            return 'CDNSKEY';\
        case 59:\
            return 'CDS';\
        case 37:\
            return 'CERT';\
        case 5:\
            return 'CNAME';\
        case 49:\
            return 'DHCID';\
        case 32769:\
            return 'DLV';\
        case 39:\
            return 'DNAME';\
        case 48:\
            return 'DNSKEY';\
        case 43:\
            return 'DS';\
        case 55:\
            return 'HIP';\
        case 13:\
            return 'HINFO';\
        case 45:\
            return 'IPSECKEY';\
        case 25:\
            return 'KEY';\
        case 36:\
            return 'KX';\
        case 29:\
            return 'LOC';\
        case 15:\
            return 'MX';\
        case 35:\
            return 'NAPTR';\
        case 2:\
            return 'NS';\
        case 47:\
            return 'NSEC';\
        case 50:\
            return 'NSEC3';\
        case 51:\
            return 'NSEC3PARAM';\
        case 12:\
            return 'PTR';\
        case 46:\
            return 'RRSIG';\
        case 17:\
            return 'RP';\
        case 24:\
            return 'SIG';\
        case 6:\
            return 'SOA';\
        case 99:\
            return 'SPF';\
        case 33:\
            return 'SRV';\
        case 44:\
            return 'SSHFP';\
        case 32768:\
            return 'TA';\
        case 249:\
            return 'TKEY';\
        case 52:\
            return 'TLSA';\
        case 250:\
            return 'TSIG';\
        case 16:\
            return 'TXT';\
        case 252:\
            return 'AXFR';\
        case 251:\
            return 'IXFR';\
        case 41:\
            return 'OPT';\
        case 255:\
            return 'ANY';\
        \}\
        return 'UNKNOWN_' + C;\
    \};\
    element.toType = function (C) \{\
        switch (C.toUpperCase()) \{\
        case 'A':\
            return 1;\
        case 'NULL':\
            return 10;\
        case 'AAAA':\
            return 28;\
        case 'AFSDB':\
            return 18;\
        case 'APL':\
            return 42;\
        case 'CAA':\
            return 257;\
        case 'CDNSKEY':\
            return 60;\
        case 'CDS':\
            return 59;\
        case 'CERT':\
            return 37;\
        case 'CNAME':\
            return 5;\
        case 'DHCID':\
            return 49;\
        case 'DLV':\
            return 32769;\
        case 'DNAME':\
            return 39;\
        case 'DNSKEY':\
            return 48;\
        case 'DS':\
            return 43;\
        case 'HIP':\
            return 55;\
        case 'HINFO':\
            return 13;\
        case 'IPSECKEY':\
            return 45;\
        case 'KEY':\
            return 25;\
        case 'KX':\
            return 36;\
        case 'LOC':\
            return 29;\
        case 'MX':\
            return 15;\
        case 'NAPTR':\
            return 35;\
        case 'NS':\
            return 2;\
        case 'NSEC':\
            return 47;\
        case 'NSEC3':\
            return 50;\
        case 'NSEC3PARAM':\
            return 51;\
        case 'PTR':\
            return 12;\
        case 'RRSIG':\
            return 46;\
        case 'RP':\
            return 17;\
        case 'SIG':\
            return 24;\
        case 'SOA':\
            return 6;\
        case 'SPF':\
            return 99;\
        case 'SRV':\
            return 33;\
        case 'SSHFP':\
            return 44;\
        case 'TA':\
            return 32768;\
        case 'TKEY':\
            return 249;\
        case 'TLSA':\
            return 52;\
        case 'TSIG':\
            return 250;\
        case 'TXT':\
            return 16;\
        case 'AXFR':\
            return 252;\
        case 'IXFR':\
            return 251;\
        case 'OPT':\
            return 41;\
        case 'ANY':\
            return 255;\
        case '*':\
            return 255;\
        \}\
        if (C.toUpperCase().startsWith('UNKNOWN_')) \{\
            return parseInt(C.slice(8));\
        \}\
        return 0;\
    \};\
\});\
var $S = D2(element => \{\
    element.toString = function (C) \{\
        switch (C) \{\
        case 0:\
            return 'NOERROR';\
        case 1:\
            return 'FORMERR';\
        case 2:\
            return 'SERVFAIL';\
        case 3:\
            return 'NXDOMAIN';\
        case 4:\
            return 'NOTIMP';\
        case 5:\
            return 'REFUSED';\
        case 6:\
            return 'YXDOMAIN';\
        case 7:\
            return 'YXRRSET';\
        case 8:\
            return 'NXRRSET';\
        case 9:\
            return 'NOTAUTH';\
        case 10:\
            return 'NOTZONE';\
        case 11:\
            return 'RCODE_11';\
        case 12:\
            return 'RCODE_12';\
        case 13:\
            return 'RCODE_13';\
        case 14:\
            return 'RCODE_14';\
        case 15:\
            return 'RCODE_15';\
        \}\
        return 'RCODE_' + C;\
    \};\
    element.toRcode = function (C) \{\
        switch (C.toUpperCase()) \{\
        case 'NOERROR':\
            return 0;\
        case 'FORMERR':\
            return 1;\
        case 'SERVFAIL':\
            return 2;\
        case 'NXDOMAIN':\
            return 3;\
        case 'NOTIMP':\
            return 4;\
        case 'REFUSED':\
            return 5;\
        case 'YXDOMAIN':\
            return 6;\
        case 'YXRRSET':\
            return 7;\
        case 'NXRRSET':\
            return 8;\
        case 'NOTAUTH':\
            return 9;\
        case 'NOTZONE':\
            return 10;\
        case 'RCODE_11':\
            return 11;\
        case 'RCODE_12':\
            return 12;\
        case 'RCODE_13':\
            return 13;\
        case 'RCODE_14':\
            return 14;\
        case 'RCODE_15':\
            return 15;\
        \}\
        return 0;\
    \};\
\});\
var WS = D2(element => \{\
    element.toString = function (C) \{\
        switch (C) \{\
        case 0:\
            return 'QUERY';\
        case 1:\
            return 'IQUERY';\
        case 2:\
            return 'STATUS';\
        case 3:\
            return 'OPCODE_3';\
        case 4:\
            return 'NOTIFY';\
        case 5:\
            return 'UPDATE';\
        case 6:\
            return 'OPCODE_6';\
        case 7:\
            return 'OPCODE_7';\
        case 8:\
            return 'OPCODE_8';\
        case 9:\
            return 'OPCODE_9';\
        case 10:\
            return 'OPCODE_10';\
        case 11:\
            return 'OPCODE_11';\
        case 12:\
            return 'OPCODE_12';\
        case 13:\
            return 'OPCODE_13';\
        case 14:\
            return 'OPCODE_14';\
        case 15:\
            return 'OPCODE_15';\
        \}\
        return 'OPCODE_' + C;\
    \};\
    element.toOpcode = function (C) \{\
        switch (C.toUpperCase()) \{\
        case 'QUERY':\
            return 0;\
        case 'IQUERY':\
            return 1;\
        case 'STATUS':\
            return 2;\
        case 'OPCODE_3':\
            return 3;\
        case 'NOTIFY':\
            return 4;\
        case 'UPDATE':\
            return 5;\
        case 'OPCODE_6':\
            return 6;\
        case 'OPCODE_7':\
            return 7;\
        case 'OPCODE_8':\
            return 8;\
        case 'OPCODE_9':\
            return 9;\
        case 'OPCODE_10':\
            return 10;\
        case 'OPCODE_11':\
            return 11;\
        case 'OPCODE_12':\
            return 12;\
        case 'OPCODE_13':\
            return 13;\
        case 'OPCODE_14':\
            return 14;\
        case 'OPCODE_15':\
            return 15;\
        \}\
        return 0;\
    \};\
\});\
var _S = D2(element => \{\
    element.toString = function (C) \{\
        switch (C) \{\
        case 1:\
            return 'IN';\
        case 2:\
            return 'CS';\
        case 3:\
            return 'CH';\
        case 4:\
            return 'HS';\
        case 255:\
            return 'ANY';\
        \}\
        return 'UNKNOWN_' + C;\
    \};\
    element.toClass = function (C) \{\
        switch (C.toUpperCase()) \{\
        case 'IN':\
            return 1;\
        case 'CS':\
            return 2;\
        case 'CH':\
            return 3;\
        case 'HS':\
            return 4;\
        case 'ANY':\
            return 255;\
        \}\
        return 0;\
    \};\
\});\
var zS = D2(element => \{\
    element.toString = function (C) \{\
        switch (C) \{\
        case 1:\
            return 'LLQ';\
        case 2:\
            return 'UL';\
        case 3:\
            return 'NSID';\
        case 5:\
            return 'DAU';\
        case 6:\
            return 'DHU';\
        case 7:\
            return 'N3U';\
        case 8:\
            return 'CLIENT_SUBNET';\
        case 9:\
            return 'EXPIRE';\
        case 10:\
            return 'COOKIE';\
        case 11:\
            return 'TCP_KEEPALIVE';\
        case 12:\
            return 'PADDING';\
        case 13:\
            return 'CHAIN';\
        case 14:\
            return 'KEY_TAG';\
        case 26946:\
            return 'DEVICEID';\
        \}\
        if (C < 0) \{\
            return null;\
        \}\
        return `OPTION_$\{ C \}`;\
    \};\
    element.toCode = function (C) \{\
        if (typeof C === 'number') \{\
            return C;\
        \}\
        if (!C) \{\
            return -1;\
        \}\
        switch (C.toUpperCase()) \{\
        case 'OPTION_0':\
            return 0;\
        case 'LLQ':\
            return 1;\
        case 'UL':\
            return 2;\
        case 'NSID':\
            return 3;\
        case 'OPTION_4':\
            return 4;\
        case 'DAU':\
            return 5;\
        case 'DHU':\
            return 6;\
        case 'N3U':\
            return 7;\
        case 'CLIENT_SUBNET':\
            return 8;\
        case 'EXPIRE':\
            return 9;\
        case 'COOKIE':\
            return 10;\
        case 'TCP_KEEPALIVE':\
            return 11;\
        case 'PADDING':\
            return 12;\
        case 'CHAIN':\
            return 13;\
        case 'KEY_TAG':\
            return 14;\
        case 'DEVICEID':\
            return 26946;\
        case 'OPTION_65535':\
            return 65535;\
        \}\
        let match = C.match(/_(\\d+)$/);\
        if (match) \{\
            return parseInt(match[1], 10);\
        \}\
        return -1;\
    \};\
\});\
var qS = D2((LS, d2) => \{\
    var exports = function (exports_1) \{\
        Object.defineProperty(exports_1, '__esModule', \{ value: true \});\
        exports_1.decode = decode;\
        exports_1.encode = encode;\
        exports_1.familyOf = familyOf;\
        exports_1.name = undefined;\
        exports_1.sizeOf = sizeOf;\
        exports_1.v6 = exports_1.v4 = undefined;\
        let re_pattern = /^(\\d\{1,3\}\\.)\{3,3\}\\d\{1,3\}$/;\
        let _size = 4;\
        let re_pattern_1 = /^(::)?(((\\d\{1,3\}\\.)\{3\}(\\d\{1,3\})\{1\})?([0-9a-f])\{0,4\}:\{0,2\})\{1,8\}(::)?$/i;\
        let _size_1 = 16;\
        let v4_1 = \{\
            name: 'v4',\
            size: _size,\
            isFormat(Z) \{\
                return re_pattern.test(Z);\
            \},\
            encode(Z, U, I) \{\
                I = ~~I;\
                U = U || new Uint8Array(I + _size);\
                let length = Z.length;\
                let _num = 0;\
                for (let z = 0; z < length;) \{\
                    let k = Z.charCodeAt(z++);\
                    if (k === 46) \{\
                        U[I++] = _num;\
                        _num = 0;\
                    \} else \{\
                        _num = _num * 10 + (k - 48);\
                    \}\
                \}\
                U[I] = _num;\
                return U;\
            \},\
            decode(Z, U) \{\
                U = ~~U;\
                return `$\{ Z[U++] \}.$\{ Z[U++] \}.$\{ Z[U++] \}.$\{ Z[U] \}`;\
            \}\
        \};\
        exports_1.v4 = v4_1;\
        let v6_1 = \{\
            name: 'v6',\
            size: _size_1,\
            isFormat(Z) \{\
                if (!(Z.length > 0)) \{\
                    return false;\
                \}\
                if (re_pattern_1.test(Z)) \{\
                    return true;\
                \}\
            \},\
            encode(Z, U, _num_31) \{\
                _num_31 = ~~_num_31;\
                let D = _num_31 + _size_1;\
                let _num = -1;\
                let _num_29 = 0;\
                let _num_30 = 0;\
                let _bool = true;\
                let _bool_1 = false;\
                U = U || new Uint8Array(_num_31 + _size_1);\
                for (let B = 0; B < Z.length; B++) \{\
                    let w = Z.charCodeAt(B);\
                    if (w === 58) \{\
                        if (_bool) \{\
                            if (_num !== -1) \{\
                                if (_num_31 < D) \{\
                                    U[_num_31] = 0;\
                                \}\
                                if (_num_31 < D - 1) \{\
                                    U[_num_31 + 1] = 0;\
                                \}\
                                _num_31 += 2;\
                            \} else \{\
                                if (_num_31 < D) \{\
                                    _num = _num_31;\
                                \}\
                            \}\
                        \} else \{\
                            if (_bool_1 === true) \{\
                                if (_num_31 < D) \{\
                                    U[_num_31] = _num_30;\
                                \}\
                                _num_31++;\
                            \} else \{\
                                if (_num_31 < D) \{\
                                    U[_num_31] = _num_29 >> 8;\
                                \}\
                                if (_num_31 < D - 1) \{\
                                    U[_num_31 + 1] = _num_29 & 255;\
                                \}\
                                _num_31 += 2;\
                            \}\
                            _num_29 = 0;\
                            _num_30 = 0;\
                        \}\
                        _bool = true;\
                        _bool_1 = false;\
                    \} else \{\
                        if (w === 46) \{\
                            if (_num_31 < D) \{\
                                U[_num_31] = _num_30;\
                            \}\
                            _num_31++;\
                            _num_30 = 0;\
                            _num_29 = 0;\
                            _bool = false;\
                            _bool_1 = true;\
                        \} else \{\
                            _bool = false;\
                            if (w >= 97) \{\
                                w -= 87;\
                            \} else \{\
                                if (w >= 65) \{\
                                    w -= 55;\
                                \} else \{\
                                    w -= 48;\
                                    _num_30 = _num_30 * 10 + w;\
                                \}\
                            \}\
                            _num_29 = (_num_29 << 4) + w;\
                        \}\
                    \}\
                \}\
                if (_bool === false) \{\
                    if (_bool_1 === true) \{\
                        if (_num_31 < D) \{\
                            U[_num_31] = _num_30;\
                        \}\
                        _num_31++;\
                    \} else \{\
                        if (_num_31 < D) \{\
                            U[_num_31] = _num_29 >> 8;\
                        \}\
                        if (_num_31 < D - 1) \{\
                            U[_num_31 + 1] = _num_29 & 255;\
                        \}\
                        _num_31 += 2;\
                    \}\
                \} else \{\
                    if (_num === 0) \{\
                        if (_num_31 < D) \{\
                            U[_num_31] = 0;\
                        \}\
                        if (_num_31 < D - 1) \{\
                            U[_num_31 + 1] = 0;\
                        \}\
                        _num_31 += 2;\
                    \} else \{\
                        if (_num !== -1) \{\
                            _num_31 += 2;\
                            for (let B = Math.min(_num_31 - 1, D - 1); B >= _num + 2; B--) \{\
                                U[B] = U[B - 2];\
                            \}\
                            U[_num] = 0;\
                            U[_num + 1] = 0;\
                            _num = _num_31;\
                        \}\
                    \}\
                \}\
                if (_num !== _num_31 && _num !== -1) \{\
                    if (_num_31 > D - 2) \{\
                        _num_31 = D - 2;\
                    \}\
                    while (D > _num)\
                        U[--D] = _num_31 < D && _num_31 > _num ? U[--_num_31] : 0;\
                \} else \{\
                    while (_num_31 < D)\
                        U[_num_31++] = 0;\
                \}\
                return U;\
            \},\
            decode(Z, U) \{\
                U = ~~U;\
                let toString = '';\
                for (let D = 0; D < _size_1; D += 2) \{\
                    if (D !== 0) \{\
                        toString += ':';\
                    \}\
                    toString += (Z[U + D] << 8 | Z[U + D + 1]).toString(16);\
                \}\
                return toString.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:\{3,4\}/, '::');\
            \}\
        \};\
        exports_1.v6 = v6_1;\
        let ip_1 = 'ip';\
        exports_1.name = ip_1;\
        function sizeOf(Z) \{\
            if (v4_1.isFormat(Z)) \{\
                return v4_1.size;\
            \}\
            if (v6_1.isFormat(Z)) \{\
                return v6_1.size;\
            \}\
            throw Error(`Invalid ip address: $\{ Z \}`);\
        \}\
        function familyOf(Z) \{\
            if (sizeOf(Z) === v4_1.size) \{\
                return 1;\
            \} else \{\
                return 2;\
            \}\
        \}\
        function encode(Z, U, I) \{\
            I = ~~I;\
            let sizeOf_1 = sizeOf(Z);\
            if (typeof U === 'function') \{\
                U = U(I + sizeOf_1);\
            \}\
            if (sizeOf_1 === v4_1.size) \{\
                return v4_1.encode(Z, U, I);\
            \}\
            return v6_1.encode(Z, U, I);\
        \}\
        function decode(Z, U, I) \{\
            U = ~~U;\
            I = I || Z.length - U;\
            if (I === v4_1.size) \{\
                return v4_1.decode(Z, U, I);\
            \}\
            if (I === v6_1.size) \{\
                return v6_1.decode(Z, U, I);\
            \}\
            throw Error(`Invalid buffer size needs to be $\{ v4_1.size \} for v4 or $\{ v6_1.size \} for v6.`);\
        \}\
        if ('default' in exports_1) \{\
            return exports_1.default;\
        \} else \{\
            return exports_1;\
        \}\
    \}(\{\});\
    if (typeof define === 'function' && define.amd) \{\
        define([], function () \{\
            return exports;\
        \});\
    \} else \{\
        if (typeof d2 === 'object' && typeof LS === 'object') \{\
            d2.exports = exports;\
        \}\
    \}\
\});\
var vS = D2(element => \{\
    var buffer_3 = (p2(), TS(l2)).Buffer;\
    var js_1 = JS();\
    var zA = $S();\
    var ws_1 = WS();\
    var _S_1 = _S_1();\
    var zS_1 = zS_1();\
    var qS_1 = qS_1();\
    var G = element.name = \{\};\
    G.encode = function (C, alloc, N, \{\
        mail: R = false\
    \} = \{\}) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(G.encodingLength(C));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        let H = N;\
        let replace = C.replace(/^\\.|\\.$/gm, '');\
        if (replace.length) \{\
            let V = [];\
            if (R) \{\
                let Y = '';\
                replace.split('.').forEach(element_4 => \{\
                    if (element_4.endsWith('\\\\')) \{\
                        Y += (Y.length ? '.' : '') + element_4.slice(0, -1);\
                    \} else \{\
                        if (V.length === 0 && Y.length) \{\
                            V.push(Y + '.' + element_4);\
                        \} else \{\
                            V.push(element_4);\
                        \}\
                    \}\
                \});\
            \} else \{\
                V = replace.split('.');\
            \}\
            for (let Y = 0; Y < V.length; Y++) \{\
                let J = alloc.write(V[Y], N + 1);\
                alloc[N] = J;\
                N += J + 1;\
            \}\
        \}\
        alloc[N++] = 0;\
        G.encode.bytes = N - H;\
        return alloc;\
    \};\
    G.encode.bytes = 0;\
    G.decode = function (C, S, \{\
        mail: N = false\
    \} = \{\}) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let R = [];\
        let H = S;\
        let _num = 0;\
        let _num_32 = 0;\
        let _bool = false;\
        while (true) \{\
            if (S >= C.length) \{\
                throw new Error('Cannot decode name (buffer overflow)');\
            \}\
            let J = C[S++];\
            _num_32 += _bool ? 0 : 1;\
            if (J === 0) \{\
                break;\
            \} else \{\
                if ((J & 192) === 0) \{\
                    if (S + J > C.length) \{\
                        throw new Error('Cannot decode name (buffer overflow)');\
                    \}\
                    _num += J + 1;\
                    if (_num > 254) \{\
                        throw new Error('Cannot decode name (name too long)');\
                    \}\
                    let W = C.toString('utf-8', S, S + J);\
                    if (N) \{\
                        W = W.replace(/\\./g, '\\\\.');\
                    \}\
                    R.push(W);\
                    S += J;\
                    _num_32 += _bool ? 0 : J;\
                \} else \{\
                    if ((J & 192) === 192) \{\
                        if (S + 1 > C.length) \{\
                            throw new Error('Cannot decode name (buffer overflow)');\
                        \}\
                        let W = C.readUInt16BE(S - 1) - 49152;\
                        if (W >= H) \{\
                            throw new Error('Cannot decode name (bad pointer)');\
                        \}\
                        S = W;\
                        H = W;\
                        _num_32 += _bool ? 0 : 1;\
                        _bool = true;\
                    \} else \{\
                        throw new Error('Cannot decode name (bad label)');\
                    \}\
                \}\
            \}\
        \}\
        G.decode.bytes = _num_32;\
        if (R.length === 0) \{\
            return '.';\
        \} else \{\
            return R.join('.');\
        \}\
    \};\
    G.decode.bytes = 0;\
    G.encodingLength = function (C) \{\
        if (C === '.' || C === '..') \{\
            return 1;\
        \}\
        return buffer_3.byteLength(C.replace(/^\\.|\\.$/gm, '')) + 2;\
    \};\
    var _ = \{\};\
    _.encode = function (C, alloc, N) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(_.encodingLength(C));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        let write = alloc.write(C, N + 1);\
        alloc[N] = write;\
        _.encode.bytes = write + 1;\
        return alloc;\
    \};\
    _.encode.bytes = 0;\
    _.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let N = C[S];\
        let toString = C.toString('utf-8', S + 1, S + 1 + N);\
        _.decode.bytes = N + 1;\
        return toString;\
    \};\
    _.decode.bytes = 0;\
    _.encodingLength = function (C) \{\
        return buffer_3.byteLength(C) + 1;\
    \};\
    var o = \{\};\
    o.encode = function (C, encodingLength, N) \{\
        if (!encodingLength) \{\
            encodingLength = o.encodingLength(C);\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        let R = (C.flags || 0) & 32767;\
        let H = C.type === 'response' ? 32768 : 0;\
        encodingLength.writeUInt16BE(C.id || 0, N);\
        encodingLength.writeUInt16BE(R | H, N + 2);\
        encodingLength.writeUInt16BE(C.questions.length, N + 4);\
        encodingLength.writeUInt16BE(C.answers.length, N + 6);\
        encodingLength.writeUInt16BE(C.authorities.length, N + 8);\
        encodingLength.writeUInt16BE(C.additionals.length, N + 10);\
        return encodingLength;\
    \};\
    o.encode.bytes = 12;\
    o.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        if (C.length < 12) \{\
            throw new Error('Header must be 12 bytes');\
        \}\
        let readUInt16BE = C.readUInt16BE(S + 2);\
        return \{\
            id: C.readUInt16BE(S),\
            type: readUInt16BE & 32768 ? 'response' : 'query',\
            flags: readUInt16BE & 32767,\
            flag_qr: (readUInt16BE >> 15 & 1) === 1,\
            opcode: ws_1.toString(readUInt16BE >> 11 & 15),\
            flag_aa: (readUInt16BE >> 10 & 1) === 1,\
            flag_tc: (readUInt16BE >> 9 & 1) === 1,\
            flag_rd: (readUInt16BE >> 8 & 1) === 1,\
            flag_ra: (readUInt16BE >> 7 & 1) === 1,\
            flag_z: (readUInt16BE >> 6 & 1) === 1,\
            flag_ad: (readUInt16BE >> 5 & 1) === 1,\
            flag_cd: (readUInt16BE >> 4 & 1) === 1,\
            rcode: zA.toString(readUInt16BE & 15),\
            questions: new Array(C.readUInt16BE(S + 4)),\
            answers: new Array(C.readUInt16BE(S + 6)),\
            authorities: new Array(C.readUInt16BE(S + 8)),\
            additionals: new Array(C.readUInt16BE(S + 10))\
        \};\
    \};\
    o.decode.bytes = 12;\
    o.encodingLength = function () \{\
        return 12;\
    \};\
    var K2 = element.unknown = \{\};\
    K2.encode = function (C, alloc, N) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(K2.encodingLength(C));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        alloc.writeUInt16BE(C.length, N);\
        C.copy(alloc, N + 2);\
        K2.encode.bytes = C.length + 2;\
        return alloc;\
    \};\
    K2.encode.bytes = 0;\
    K2.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let readUInt16BE = C.readUInt16BE(S);\
        let slice = C.slice(S + 2, S + 2 + readUInt16BE);\
        K2.decode.bytes = readUInt16BE + 2;\
        return slice;\
    \};\
    K2.decode.bytes = 0;\
    K2.encodingLength = function (C) \{\
        return C.length + 2;\
    \};\
    var R2 = element.ns = \{\};\
    R2.encode = function (input, alloc, N) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(R2.encodingLength(input));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        G.encode(input, alloc, N + 2);\
        alloc.writeUInt16BE(G.encode.bytes, N);\
        R2.encode.bytes = G.encode.bytes + 2;\
        return alloc;\
    \};\
    R2.encode.bytes = 0;\
    R2.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let readUInt16BE = C.readUInt16BE(S);\
        let decode = G.decode(C, S + 2);\
        R2.decode.bytes = readUInt16BE + 2;\
        return decode;\
    \};\
    R2.decode.bytes = 0;\
    R2.encodingLength = function (C) \{\
        return G.encodingLength(C) + 2;\
    \};\
    var T2 = element.soa = \{\};\
    T2.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(T2.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_1 = bytes;\
        bytes += 2;\
        G.encode(C.mname, alloc, bytes);\
        bytes += G.encode.bytes;\
        G.encode(C.rname, alloc, bytes, \{ mail: true \});\
        bytes += G.encode.bytes;\
        alloc.writeUInt32BE(C.serial || 0, bytes);\
        bytes += 4;\
        alloc.writeUInt32BE(C.refresh || 0, bytes);\
        bytes += 4;\
        alloc.writeUInt32BE(C.retry || 0, bytes);\
        bytes += 4;\
        alloc.writeUInt32BE(C.expire || 0, bytes);\
        bytes += 4;\
        alloc.writeUInt32BE(C.minimum || 0, bytes);\
        bytes += 4;\
        alloc.writeUInt16BE(bytes - bytes_1 - 2, bytes_1);\
        T2.encode.bytes = bytes - bytes_1;\
        return alloc;\
    \};\
    T2.encode.bytes = 0;\
    T2.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_2 = bytes;\
        let R = \{\};\
        bytes += 2;\
        R.mname = G.decode(C, bytes);\
        bytes += G.decode.bytes;\
        R.rname = G.decode(C, bytes, \{ mail: true \});\
        bytes += G.decode.bytes;\
        R.serial = C.readUInt32BE(bytes);\
        bytes += 4;\
        R.refresh = C.readUInt32BE(bytes);\
        bytes += 4;\
        R.retry = C.readUInt32BE(bytes);\
        bytes += 4;\
        R.expire = C.readUInt32BE(bytes);\
        bytes += 4;\
        R.minimum = C.readUInt32BE(bytes);\
        bytes += 4;\
        T2.decode.bytes = bytes - bytes_2;\
        return R;\
    \};\
    T2.decode.bytes = 0;\
    T2.encodingLength = function (C) \{\
        return 22 + G.encodingLength(C.mname) + G.encodingLength(C.rname);\
    \};\
    var Y2 = element.txt = \{\};\
    Y2.encode = function (C, alloc, length) \{\
        if (!Array.isArray(C)) \{\
            C = [C];\
        \}\
        for (let H = 0; H < C.length; H++) \{\
            if (typeof C[H] === 'string') \{\
                C[H] = buffer_3.from(C[H]);\
            \}\
            if (!buffer_3.isBuffer(C[H])) \{\
                throw new Error('Must be a Buffer');\
            \}\
        \}\
        if (!alloc) \{\
            alloc = buffer_3.alloc(Y2.encodingLength(C));\
        \}\
        if (!length) \{\
            length = 0;\
        \}\
        let length_14 = length;\
        length += 2;\
        C.forEach(function (H) \{\
            alloc[length++] = H.length;\
            H.copy(alloc, length, 0, H.length);\
            length += H.length;\
        \});\
        alloc.writeUInt16BE(length - length_14 - 2, length_14);\
        Y2.encode.bytes = length - length_14;\
        return alloc;\
    \};\
    Y2.encode.bytes = 0;\
    Y2.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let N = S;\
        let readUInt16BE = C.readUInt16BE(S);\
        S += 2;\
        let H = [];\
        while (readUInt16BE > 0) \{\
            let M = C[S++];\
            --readUInt16BE;\
            if (readUInt16BE < M) \{\
                throw new Error('Buffer overflow');\
            \}\
            H.push(C.slice(S, S + M));\
            S += M;\
            readUInt16BE -= M;\
        \}\
        Y2.decode.bytes = S - N;\
        return H;\
    \};\
    Y2.decode.bytes = 0;\
    Y2.encodingLength = function (C) \{\
        if (!Array.isArray(C)) \{\
            C = [C];\
        \}\
        let _num = 2;\
        C.forEach(function (N) \{\
            if (typeof N === 'string') \{\
                _num += buffer_3.byteLength(N) + 1;\
            \} else \{\
                _num += N.length + 1;\
            \}\
        \});\
        return _num;\
    \};\
    var H2 = element.null = \{\};\
    H2.encode = function (from, alloc, length_13) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(H2.encodingLength(from));\
        \}\
        if (!length_13) \{\
            length_13 = 0;\
        \}\
        if (typeof from === 'string') \{\
            from = buffer_3.from(from);\
        \}\
        if (!from) \{\
            from = buffer_3.alloc(0);\
        \}\
        let length_13_1 = length_13;\
        length_13 += 2;\
        let length = from.length;\
        from.copy(alloc, length_13, 0, length);\
        length_13 += length;\
        alloc.writeUInt16BE(length_13 - length_13_1 - 2, length_13_1);\
        H2.encode.bytes = length_13 - length_13_1;\
        return alloc;\
    \};\
    H2.encode.bytes = 0;\
    H2.decode = function (C, readUInt16BE_1) \{\
        if (!readUInt16BE_1) \{\
            readUInt16BE_1 = 0;\
        \}\
        let readUInt16BE_1_1 = readUInt16BE_1;\
        let readUInt16BE = C.readUInt16BE(readUInt16BE_1);\
        readUInt16BE_1 += 2;\
        let slice = C.slice(readUInt16BE_1, readUInt16BE_1 + readUInt16BE);\
        readUInt16BE_1 += readUInt16BE;\
        H2.decode.bytes = readUInt16BE_1 - readUInt16BE_1_1;\
        return slice;\
    \};\
    H2.decode.bytes = 0;\
    H2.encodingLength = function (C) \{\
        if (!C) \{\
            return 2;\
        \}\
        return (buffer_3.isBuffer(C) ? C.length : buffer_3.byteLength(C)) + 2;\
    \};\
    var X2 = element.hinfo = \{\};\
    X2.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(X2.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_3 = bytes;\
        bytes += 2;\
        _.encode(C.cpu, alloc, bytes);\
        bytes += _.encode.bytes;\
        _.encode(C.os, alloc, bytes);\
        bytes += _.encode.bytes;\
        alloc.writeUInt16BE(bytes - bytes_3 - 2, bytes_3);\
        X2.encode.bytes = bytes - bytes_3;\
        return alloc;\
    \};\
    X2.encode.bytes = 0;\
    X2.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_4 = bytes;\
        let R = \{\};\
        bytes += 2;\
        R.cpu = _.decode(C, bytes);\
        bytes += _.decode.bytes;\
        R.os = _.decode(C, bytes);\
        bytes += _.decode.bytes;\
        X2.decode.bytes = bytes - bytes_4;\
        return R;\
    \};\
    X2.decode.bytes = 0;\
    X2.encodingLength = function (C) \{\
        return _.encodingLength(C.cpu) + _.encodingLength(C.os) + 2;\
    \};\
    var cname = element.ptr = \{\};\
    var LA = element.cname = cname;\
    var qA = element.dname = cname;\
    cname.encode = function (input, alloc, N) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(cname.encodingLength(input));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        G.encode(input, alloc, N + 2);\
        alloc.writeUInt16BE(G.encode.bytes, N);\
        cname.encode.bytes = G.encode.bytes + 2;\
        return alloc;\
    \};\
    cname.encode.bytes = 0;\
    cname.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let decode = G.decode(C, S + 2);\
        cname.decode.bytes = G.decode.bytes + 2;\
        return decode;\
    \};\
    cname.decode.bytes = 0;\
    cname.encodingLength = function (C) \{\
        return G.encodingLength(C) + 2;\
    \};\
    var I2 = element.srv = \{\};\
    I2.encode = function (C, alloc, N) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(I2.encodingLength(C));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        alloc.writeUInt16BE(C.priority || 0, N + 2);\
        alloc.writeUInt16BE(C.weight || 0, N + 4);\
        alloc.writeUInt16BE(C.port || 0, N + 6);\
        G.encode(C.target, alloc, N + 8);\
        let R = G.encode.bytes + 6;\
        alloc.writeUInt16BE(R, N);\
        I2.encode.bytes = R + 2;\
        return alloc;\
    \};\
    I2.encode.bytes = 0;\
    I2.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let readUInt16BE = C.readUInt16BE(S);\
        let R = \{\};\
        R.priority = C.readUInt16BE(S + 2);\
        R.weight = C.readUInt16BE(S + 4);\
        R.port = C.readUInt16BE(S + 6);\
        R.target = G.decode(C, S + 8);\
        I2.decode.bytes = readUInt16BE + 2;\
        return R;\
    \};\
    I2.decode.bytes = 0;\
    I2.encodingLength = function (C) \{\
        return 8 + G.encodingLength(C.target);\
    \};\
    var b = element.caa = \{\};\
    b.ISSUER_CRITICAL = 128;\
    b.encode = function (C, alloc, bytes) \{\
        let encodingLength = b.encodingLength(C);\
        if (!alloc) \{\
            alloc = buffer_3.alloc(b.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        if (C.issuerCritical) \{\
            C.flags = b.ISSUER_CRITICAL;\
        \}\
        alloc.writeUInt16BE(encodingLength - 2, bytes);\
        bytes += 2;\
        alloc.writeUInt8(C.flags || 0, bytes);\
        bytes += 1;\
        _.encode(C.tag, alloc, bytes);\
        bytes += _.encode.bytes;\
        alloc.write(C.value, bytes);\
        bytes += buffer_3.byteLength(C.value);\
        b.encode.bytes = encodingLength;\
        return alloc;\
    \};\
    b.encode.bytes = 0;\
    b.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let readUInt16BE = C.readUInt16BE(bytes);\
        bytes += 2;\
        let bytes_5 = bytes;\
        let H = \{\};\
        H.flags = C.readUInt8(bytes);\
        bytes += 1;\
        H.tag = _.decode(C, bytes);\
        bytes += _.decode.bytes;\
        H.value = C.toString('utf-8', bytes, bytes_5 + readUInt16BE);\
        H.issuerCritical = !!(H.flags & b.ISSUER_CRITICAL);\
        b.decode.bytes = readUInt16BE + 2;\
        return H;\
    \};\
    b.decode.bytes = 0;\
    b.encodingLength = function (C) \{\
        return _.encodingLength(C.tag) + _.encodingLength(C.value) + 2;\
    \};\
    var U2 = element.mx = \{\};\
    U2.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(U2.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_6 = bytes;\
        bytes += 2;\
        alloc.writeUInt16BE(C.preference || 0, bytes);\
        bytes += 2;\
        G.encode(C.exchange, alloc, bytes);\
        bytes += G.encode.bytes;\
        alloc.writeUInt16BE(bytes - bytes_6 - 2, bytes_6);\
        U2.encode.bytes = bytes - bytes_6;\
        return alloc;\
    \};\
    U2.encode.bytes = 0;\
    U2.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_7 = bytes;\
        let R = \{\};\
        bytes += 2;\
        R.preference = C.readUInt16BE(bytes);\
        bytes += 2;\
        R.exchange = G.decode(C, bytes);\
        bytes += G.decode.bytes;\
        U2.decode.bytes = bytes - bytes_7;\
        return R;\
    \};\
    U2.encodingLength = function (C) \{\
        return 4 + G.encodingLength(C.exchange);\
    \};\
    var P2 = element.a = \{\};\
    P2.encode = function (input, alloc, N) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(P2.encodingLength(input));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        alloc.writeUInt16BE(4, N);\
        N += 2;\
        qS_1.v4.encode(input, alloc, N);\
        P2.encode.bytes = 6;\
        return alloc;\
    \};\
    P2.encode.bytes = 0;\
    P2.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        S += 2;\
        let decode = qS_1.v4.decode(C, S);\
        P2.decode.bytes = 6;\
        return decode;\
    \};\
    P2.decode.bytes = 0;\
    P2.encodingLength = function () \{\
        return 6;\
    \};\
    var M2 = element.aaaa = \{\};\
    M2.encode = function (input, alloc, N) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(M2.encodingLength(input));\
        \}\
        if (!N) \{\
            N = 0;\
        \}\
        alloc.writeUInt16BE(16, N);\
        N += 2;\
        qS_1.v6.encode(input, alloc, N);\
        M2.encode.bytes = 18;\
        return alloc;\
    \};\
    M2.encode.bytes = 0;\
    M2.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        S += 2;\
        let decode = qS_1.v6.decode(C, S);\
        M2.decode.bytes = 18;\
        return decode;\
    \};\
    M2.decode.bytes = 0;\
    M2.encodingLength = function () \{\
        return 18;\
    \};\
    var n = element.option = \{\};\
    n.encode = function (C, alloc, length) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(n.encodingLength(C));\
        \}\
        if (!length) \{\
            length = 0;\
        \}\
        let length_15 = length;\
        let toCode = zS_1.toCode(C.code);\
        alloc.writeUInt16BE(toCode, length);\
        length += 2;\
        if (C.data) \{\
            alloc.writeUInt16BE(C.data.length, length);\
            length += 2;\
            C.data.copy(alloc, length);\
            length += C.data.length;\
        \} else \{\
            switch (toCode) \{\
            case 8:\
                let M = C.sourcePrefixLength || 0;\
                let V = C.family || qS_1.familyOf(C.ip);\
                let Y = qS_1.encode(C.ip, buffer_3.alloc);\
                let J = Math.ceil(M / 8);\
                alloc.writeUInt16BE(J + 4, length);\
                length += 2;\
                alloc.writeUInt16BE(V, length);\
                length += 2;\
                alloc.writeUInt8(M, length++);\
                alloc.writeUInt8(C.scopePrefixLength || 0, length++);\
                Y.copy(alloc, length, 0, J);\
                length += J;\
                break;\
            case 11:\
                if (C.timeout) \{\
                    alloc.writeUInt16BE(2, length);\
                    length += 2;\
                    alloc.writeUInt16BE(C.timeout, length);\
                    length += 2;\
                \} else \{\
                    alloc.writeUInt16BE(0, length);\
                    length += 2;\
                \}\
                break;\
            case 12:\
                let W = C.length || 0;\
                alloc.writeUInt16BE(W, length);\
                length += 2;\
                alloc.fill(0, length, length + W);\
                length += W;\
                break;\
            case 14:\
                let y = C.tags.length * 2;\
                alloc.writeUInt16BE(y, length);\
                length += 2;\
                for (let j of C.tags) \{\
                    alloc.writeUInt16BE(j, length);\
                    length += 2;\
                \}\
                break;\
            default:\
                throw new Error(`Unknown roption code: $\{ C.code \}`);\
            \}\
        \}\
        n.encode.bytes = length - length_15;\
        return alloc;\
    \};\
    n.encode.bytes = 0;\
    n.decode = function (C, S) \{\
        if (!S) \{\
            S = 0;\
        \}\
        let N = \{\};\
        N.code = C.readUInt16BE(S);\
        N.type = zS_1.toString(N.code);\
        S += 2;\
        let readUInt16BE = C.readUInt16BE(S);\
        switch (S += 2, N.data = C.slice(S, S + readUInt16BE), N.code) \{\
        case 8:\
            N.family = C.readUInt16BE(S);\
            S += 2;\
            N.sourcePrefixLength = C.readUInt8(S++);\
            N.scopePrefixLength = C.readUInt8(S++);\
            let H = buffer_3.alloc(N.family === 1 ? 4 : 16);\
            C.copy(H, 0, S, S + readUInt16BE - 4);\
            N.ip = qS_1.decode(H);\
            break;\
        case 11:\
            if (readUInt16BE > 0) \{\
                N.timeout = C.readUInt16BE(S);\
                S += 2;\
            \}\
            break;\
        case 14:\
            N.tags = [];\
            for (let M = 0; M < readUInt16BE; M += 2) \{\
                N.tags.push(C.readUInt16BE(S));\
                S += 2;\
            \}\
        \}\
        n.decode.bytes = readUInt16BE + 4;\
        return N;\
    \};\
    n.decode.bytes = 0;\
    n.encodingLength = function (C) \{\
        if (C.data) \{\
            return C.data.length + 4;\
        \}\
        switch (zS_1.toCode(C.code)) \{\
        case 8:\
            let N = C.sourcePrefixLength || 0;\
            return Math.ceil(N / 8) + 8;\
        case 11:\
            if (typeof C.timeout === 'number') \{\
                return 6;\
            \} else \{\
                return 4;\
            \}\
        case 12:\
            return C.length + 4;\
        case 14:\
            return 4 + C.tags.length * 2;\
        \}\
        throw new Error(`Unknown roption code: $\{ C.code \}`);\
    \};\
    var i = element.opt = \{\};\
    i.encode = function (C, alloc, z2_2) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(i.encodingLength(C));\
        \}\
        if (!z2_2) \{\
            z2_2 = 0;\
        \}\
        let z2_1 = z2_2;\
        let H = $2(C, n);\
        alloc.writeUInt16BE(H, z2_2);\
        z2_2 = z2_2(C, n, alloc, z2_2 + 2);\
        i.encode.bytes = z2_2 - z2_1;\
        return alloc;\
    \};\
    i.encode.bytes = 0;\
    i.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_8 = bytes;\
        let R = [];\
        let readUInt16BE = C.readUInt16BE(bytes);\
        bytes += 2;\
        let _num = 0;\
        while (readUInt16BE > 0)\
            R[_num++] = n.decode(C, bytes), bytes += n.decode.bytes, readUInt16BE -= n.decode.bytes;\
        i.decode.bytes = bytes - bytes_8;\
        return R;\
    \};\
    i.decode.bytes = 0;\
    i.encodingLength = function (C) \{\
        return 2 + $2(C || [], n);\
    \};\
    var p = element.dnskey = \{\};\
    p.PROTOCOL_DNSSEC = 3;\
    p.ZONE_KEY = 128;\
    p.SECURE_ENTRYPOINT = 32768;\
    p.encode = function (C, alloc, length) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(p.encodingLength(C));\
        \}\
        if (!length) \{\
            length = 0;\
        \}\
        let length_16 = length;\
        let key = C.key;\
        if (!buffer_3.isBuffer(key)) \{\
            throw new Error('Key must be a Buffer');\
        \}\
        length += 2;\
        alloc.writeUInt16BE(C.flags, length);\
        length += 2;\
        alloc.writeUInt8(p.PROTOCOL_DNSSEC, length);\
        length += 1;\
        alloc.writeUInt8(C.algorithm, length);\
        length += 1;\
        key.copy(alloc, length, 0, key.length);\
        length += key.length;\
        p.encode.bytes = length - length_16;\
        alloc.writeUInt16BE(p.encode.bytes - 2, length_16);\
        return alloc;\
    \};\
    p.encode.bytes = 0;\
    p.decode = function (C, length) \{\
        if (!length) \{\
            length = 0;\
        \}\
        let length_17 = length;\
        var R = \{\};\
        var readUInt16BE = C.readUInt16BE(length);\
        length += 2;\
        R.flags = C.readUInt16BE(length);\
        length += 2;\
        if (C.readUInt8(length) !== p.PROTOCOL_DNSSEC) \{\
            throw new Error('Protocol must be 3');\
        \}\
        length += 1;\
        R.algorithm = C.readUInt8(length);\
        length += 1;\
        R.key = C.slice(length, length_17 + readUInt16BE + 2);\
        length += R.key.length;\
        p.decode.bytes = length - length_17;\
        return R;\
    \};\
    p.decode.bytes = 0;\
    p.encodingLength = function (C) \{\
        return 6 + buffer_3.byteLength(C.key);\
    \};\
    var t = element.rrsig = \{\};\
    t.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(t.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_9 = bytes;\
        let signature = C.signature;\
        if (!buffer_3.isBuffer(signature)) \{\
            throw new Error('Signature must be a Buffer');\
        \}\
        bytes += 2;\
        alloc.writeUInt16BE(js_1.toType(C.typeCovered), bytes);\
        bytes += 2;\
        alloc.writeUInt8(C.algorithm, bytes);\
        bytes += 1;\
        alloc.writeUInt8(C.labels, bytes);\
        bytes += 1;\
        alloc.writeUInt32BE(C.originalTTL, bytes);\
        bytes += 4;\
        alloc.writeUInt32BE(C.expiration, bytes);\
        bytes += 4;\
        alloc.writeUInt32BE(C.inception, bytes);\
        bytes += 4;\
        alloc.writeUInt16BE(C.keyTag, bytes);\
        bytes += 2;\
        G.encode(C.signersName, alloc, bytes);\
        bytes += G.encode.bytes;\
        signature.copy(alloc, bytes, 0, signature.length);\
        bytes += signature.length;\
        t.encode.bytes = bytes - bytes_9;\
        alloc.writeUInt16BE(t.encode.bytes - 2, bytes_9);\
        return alloc;\
    \};\
    t.encode.bytes = 0;\
    t.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_10 = bytes;\
        var R = \{\};\
        var readUInt16BE = C.readUInt16BE(bytes);\
        bytes += 2;\
        R.typeCovered = js_1.toString(C.readUInt16BE(bytes));\
        bytes += 2;\
        R.algorithm = C.readUInt8(bytes);\
        bytes += 1;\
        R.labels = C.readUInt8(bytes);\
        bytes += 1;\
        R.originalTTL = C.readUInt32BE(bytes);\
        bytes += 4;\
        R.expiration = C.readUInt32BE(bytes);\
        bytes += 4;\
        R.inception = C.readUInt32BE(bytes);\
        bytes += 4;\
        R.keyTag = C.readUInt16BE(bytes);\
        bytes += 2;\
        R.signersName = G.decode(C, bytes);\
        bytes += G.decode.bytes;\
        R.signature = C.slice(bytes, bytes_10 + readUInt16BE + 2);\
        bytes += R.signature.length;\
        t.decode.bytes = bytes - bytes_10;\
        return R;\
    \};\
    t.decode.bytes = 0;\
    t.encodingLength = function (C) \{\
        return 20 + G.encodingLength(C.signersName) + buffer_3.byteLength(C.signature);\
    \};\
    var f = element.rp = \{\};\
    f.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(f.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_11 = bytes;\
        bytes += 2;\
        G.encode(C.mbox || '.', alloc, bytes, \{ mail: true \});\
        bytes += G.encode.bytes;\
        G.encode(C.txt || '.', alloc, bytes);\
        bytes += G.encode.bytes;\
        f.encode.bytes = bytes - bytes_11;\
        alloc.writeUInt16BE(f.encode.bytes - 2, bytes_11);\
        return alloc;\
    \};\
    f.encode.bytes = 0;\
    f.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_12 = bytes;\
        let R = \{\};\
        bytes += 2;\
        R.mbox = G.decode(C, bytes, \{ mail: true \}) || '.';\
        bytes += G.decode.bytes;\
        R.txt = G.decode(C, bytes) || '.';\
        bytes += G.decode.bytes;\
        f.decode.bytes = bytes - bytes_12;\
        return R;\
    \};\
    f.decode.bytes = 0;\
    f.encodingLength = function (C) \{\
        return 2 + G.encodingLength(C.mbox || '.') + G.encodingLength(C.txt || '.');\
    \};\
    var g = \{\};\
    g.encode = function (C, alloc, length) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(g.encodingLength(C));\
        \}\
        if (!length) \{\
            length = 0;\
        \}\
        let length_18 = length;\
        var H = [];\
        for (var _num = 0; _num < C.length; _num++) \{\
            var toType = js_1.toType(C[_num]);\
            if (H[toType >> 8] === undefined) \{\
                H[toType >> 8] = [];\
            \}\
            H[toType >> 8][toType >> 3 & 31] |= 1 << 7 - (toType & 7);\
        \}\
        for (_num = 0; _num < H.length; _num++) \{\
            if (H[_num] !== undefined) \{\
                var from = buffer_3.from(H[_num]);\
                alloc.writeUInt8(_num, length);\
                length += 1;\
                alloc.writeUInt8(from.length, length);\
                length += 1;\
                from.copy(alloc, length);\
                length += from.length;\
            \}\
        \}\
        g.encode.bytes = length - length_18;\
        return alloc;\
    \};\
    g.encode.bytes = 0;\
    g.decode = function (C, readUInt8_1_1, N) \{\
        if (!readUInt8_1_1) \{\
            readUInt8_1_1 = 0;\
        \}\
        let readUInt8_1_1_1 = readUInt8_1_1;\
        var H = [];\
        while (readUInt8_1_1 - readUInt8_1_1_1 < N) \{\
            var readUInt8 = C.readUInt8(readUInt8_1_1);\
            readUInt8_1_1 += 1;\
            var readUInt8_1 = C.readUInt8(readUInt8_1_1);\
            readUInt8_1_1 += 1;\
            for (var _num = 0; _num < readUInt8_1; _num++) \{\
                var readUInt8_2 = C.readUInt8(readUInt8_1_1 + _num);\
                for (var _num_33 = 0; _num_33 < 8; _num_33++) \{\
                    if (readUInt8_2 & 1 << 7 - _num_33) \{\
                        var items = js_1.toString(readUInt8 << 8 | _num << 3 | _num_33);\
                        H.push(items);\
                    \}\
                \}\
            \}\
            readUInt8_1_1 += readUInt8_1;\
        \}\
        g.decode.bytes = readUInt8_1_1 - readUInt8_1_1_1;\
        return H;\
    \};\
    g.decode.bytes = 0;\
    g.encodingLength = function (C) \{\
        var S = [];\
        for (var _num = 0; _num < C.length; _num++) \{\
            var toType = js_1.toType(C[_num]);\
            S[toType >> 8] = Math.max(S[toType >> 8] || 0, toType & 255);\
        \}\
        var _num_34 = 0;\
        for (_num = 0; _num < S.length; _num++) \{\
            if (S[_num] !== undefined) \{\
                _num_34 += 2 + Math.ceil((S[_num] + 1) / 8);\
            \}\
        \}\
        return _num_34;\
    \};\
    var S2 = element.nsec = \{\};\
    S2.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(S2.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_13 = bytes;\
        bytes += 2;\
        G.encode(C.nextDomain, alloc, bytes);\
        bytes += G.encode.bytes;\
        g.encode(C.rrtypes, alloc, bytes);\
        bytes += g.encode.bytes;\
        S2.encode.bytes = bytes - bytes_13;\
        alloc.writeUInt16BE(S2.encode.bytes - 2, bytes_13);\
        return alloc;\
    \};\
    S2.encode.bytes = 0;\
    S2.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_14 = bytes;\
        var R = \{\};\
        var readUInt16BE = C.readUInt16BE(bytes);\
        bytes += 2;\
        R.nextDomain = G.decode(C, bytes);\
        bytes += G.decode.bytes;\
        R.rrtypes = g.decode(C, bytes, readUInt16BE - (bytes - bytes_14));\
        bytes += g.decode.bytes;\
        S2.decode.bytes = bytes - bytes_14;\
        return R;\
    \};\
    S2.decode.bytes = 0;\
    S2.encodingLength = function (C) \{\
        return 2 + G.encodingLength(C.nextDomain) + g.encodingLength(C.rrtypes);\
    \};\
    var A2 = element.nsec3 = \{\};\
    A2.encode = function (C, alloc, length) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(A2.encodingLength(C));\
        \}\
        if (!length) \{\
            length = 0;\
        \}\
        let length_19 = length;\
        let salt = C.salt;\
        if (!buffer_3.isBuffer(salt)) \{\
            throw new Error('salt must be a Buffer');\
        \}\
        let nextDomain = C.nextDomain;\
        if (!buffer_3.isBuffer(nextDomain)) \{\
            throw new Error('nextDomain must be a Buffer');\
        \}\
        length += 2;\
        alloc.writeUInt8(C.algorithm, length);\
        length += 1;\
        alloc.writeUInt8(C.flags, length);\
        length += 1;\
        alloc.writeUInt16BE(C.iterations, length);\
        length += 2;\
        alloc.writeUInt8(salt.length, length);\
        length += 1;\
        salt.copy(alloc, length, 0, salt.length);\
        length += salt.length;\
        alloc.writeUInt8(nextDomain.length, length);\
        length += 1;\
        nextDomain.copy(alloc, length, 0, nextDomain.length);\
        length += nextDomain.length;\
        g.encode(C.rrtypes, alloc, length);\
        length += g.encode.bytes;\
        A2.encode.bytes = length - length_19;\
        alloc.writeUInt16BE(A2.encode.bytes - 2, length_19);\
        return alloc;\
    \};\
    A2.encode.bytes = 0;\
    A2.decode = function (C, readUInt8_4) \{\
        if (!readUInt8_4) \{\
            readUInt8_4 = 0;\
        \}\
        let readUInt8_4_1 = readUInt8_4;\
        var R = \{\};\
        var readUInt16BE = C.readUInt16BE(readUInt8_4);\
        readUInt8_4 += 2;\
        R.algorithm = C.readUInt8(readUInt8_4);\
        readUInt8_4 += 1;\
        R.flags = C.readUInt8(readUInt8_4);\
        readUInt8_4 += 1;\
        R.iterations = C.readUInt16BE(readUInt8_4);\
        readUInt8_4 += 2;\
        let readUInt8 = C.readUInt8(readUInt8_4);\
        readUInt8_4 += 1;\
        R.salt = C.slice(readUInt8_4, readUInt8_4 + readUInt8);\
        readUInt8_4 += readUInt8;\
        let readUInt8_3 = C.readUInt8(readUInt8_4);\
        readUInt8_4 += 1;\
        R.nextDomain = C.slice(readUInt8_4, readUInt8_4 + readUInt8_3);\
        readUInt8_4 += readUInt8_3;\
        R.rrtypes = g.decode(C, readUInt8_4, readUInt16BE - (readUInt8_4 - readUInt8_4_1));\
        readUInt8_4 += g.decode.bytes;\
        A2.decode.bytes = readUInt8_4 - readUInt8_4_1;\
        return R;\
    \};\
    A2.decode.bytes = 0;\
    A2.encodingLength = function (C) \{\
        return 8 + C.salt.length + C.nextDomain.length + g.encodingLength(C.rrtypes);\
    \};\
    var C2 = element.ds = \{\};\
    C2.encode = function (C, alloc, length) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(C2.encodingLength(C));\
        \}\
        if (!length) \{\
            length = 0;\
        \}\
        let length_20 = length;\
        let digest = C.digest;\
        if (!buffer_3.isBuffer(digest)) \{\
            throw new Error('Digest must be a Buffer');\
        \}\
        length += 2;\
        alloc.writeUInt16BE(C.keyTag, length);\
        length += 2;\
        alloc.writeUInt8(C.algorithm, length);\
        length += 1;\
        alloc.writeUInt8(C.digestType, length);\
        length += 1;\
        digest.copy(alloc, length, 0, digest.length);\
        length += digest.length;\
        C2.encode.bytes = length - length_20;\
        alloc.writeUInt16BE(C2.encode.bytes - 2, length_20);\
        return alloc;\
    \};\
    C2.encode.bytes = 0;\
    C2.decode = function (C, length) \{\
        if (!length) \{\
            length = 0;\
        \}\
        let length_21 = length;\
        var R = \{\};\
        var readUInt16BE = C.readUInt16BE(length);\
        length += 2;\
        R.keyTag = C.readUInt16BE(length);\
        length += 2;\
        R.algorithm = C.readUInt8(length);\
        length += 1;\
        R.digestType = C.readUInt8(length);\
        length += 1;\
        R.digest = C.slice(length, length_21 + readUInt16BE + 2);\
        length += R.digest.length;\
        C2.decode.bytes = length - length_21;\
        return R;\
    \};\
    C2.decode.bytes = 0;\
    C2.encodingLength = function (C) \{\
        return 6 + buffer_3.byteLength(C.digest);\
    \};\
    var u = element.sshfp = \{\};\
    u.getFingerprintLengthForHashType = function C(S) \{\
        switch (S) \{\
        case 1:\
            return 20;\
        case 2:\
            return 32;\
        \}\
    \};\
    u.encode = function C(S, N, R) \{\
        if (!N) \{\
            N = buffer_3.alloc(u.encodingLength(S));\
        \}\
        if (!R) \{\
            R = 0;\
        \}\
        let H = R;\
        R += 2;\
        N[R] = S.algorithm;\
        R += 1;\
        N[R] = S.hash;\
        R += 1;\
        let M = buffer_3.from(S.fingerprint.toUpperCase(), 'hex');\
        if (M.length !== u.getFingerprintLengthForHashType(S.hash)) \{\
            throw new Error('Invalid fingerprint length');\
        \}\
        M.copy(N, R);\
        R += M.byteLength;\
        u.encode.bytes = R - H;\
        N.writeUInt16BE(u.encode.bytes - 2, H);\
        return N;\
    \};\
    u.encode.bytes = 0;\
    u.decode = function C(S, N) \{\
        if (!N) \{\
            N = 0;\
        \}\
        let R = N;\
        let H = \{\};\
        N += 2;\
        H.algorithm = S[N];\
        N += 1;\
        H.hash = S[N];\
        N += 1;\
        let M = u.getFingerprintLengthForHashType(H.hash);\
        H.fingerprint = S.slice(N, N + M).toString('hex').toUpperCase();\
        N += M;\
        u.decode.bytes = N - R;\
        return H;\
    \};\
    u.decode.bytes = 0;\
    u.encodingLength = function (C) \{\
        return 4 + buffer_3.from(C.fingerprint, 'hex').byteLength;\
    \};\
    var N2 = element.naptr = \{\};\
    N2.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(N2.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_15 = bytes;\
        bytes += 2;\
        alloc.writeUInt16BE(C.order || 0, bytes);\
        bytes += 2;\
        alloc.writeUInt16BE(C.preference || 0, bytes);\
        bytes += 2;\
        _.encode(C.flags, alloc, bytes);\
        bytes += _.encode.bytes;\
        _.encode(C.services, alloc, bytes);\
        bytes += _.encode.bytes;\
        _.encode(C.regexp, alloc, bytes);\
        bytes += _.encode.bytes;\
        G.encode(C.replacement, alloc, bytes);\
        bytes += G.encode.bytes;\
        N2.encode.bytes = bytes - bytes_15;\
        alloc.writeUInt16BE(N2.encode.bytes - 2, bytes_15);\
        return alloc;\
    \};\
    N2.encode.bytes = 0;\
    N2.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_16 = bytes;\
        let R = \{\};\
        bytes += 2;\
        R.order = C.readUInt16BE(bytes);\
        bytes += 2;\
        R.preference = C.readUInt16BE(bytes);\
        bytes += 2;\
        R.flags = _.decode(C, bytes);\
        bytes += _.decode.bytes;\
        R.services = _.decode(C, bytes);\
        bytes += _.decode.bytes;\
        R.regexp = _.decode(C, bytes);\
        bytes += _.decode.bytes;\
        R.replacement = G.decode(C, bytes);\
        bytes += G.decode.bytes;\
        N2.decode.bytes = bytes - bytes_16;\
        return R;\
    \};\
    N2.decode.bytes = 0;\
    N2.encodingLength = function (C) \{\
        return _.encodingLength(C.flags) + _.encodingLength(C.services) + _.encodingLength(C.regexp) + G.encodingLength(C.replacement) + 6;\
    \};\
    var E2 = element.tlsa = \{\};\
    E2.encode = function (C, alloc, length) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(E2.encodingLength(C));\
        \}\
        if (!length) \{\
            length = 0;\
        \}\
        let length_22 = length;\
        let certificate = C.certificate;\
        if (!buffer_3.isBuffer(certificate)) \{\
            throw new Error('Certificate must be a Buffer');\
        \}\
        length += 2;\
        alloc.writeUInt8(C.usage, length);\
        length += 1;\
        alloc.writeUInt8(C.selector, length);\
        length += 1;\
        alloc.writeUInt8(C.matchingType, length);\
        length += 1;\
        certificate.copy(alloc, length, 0, certificate.length);\
        length += certificate.length;\
        E2.encode.bytes = length - length_22;\
        alloc.writeUInt16BE(E2.encode.bytes - 2, length_22);\
        return alloc;\
    \};\
    E2.encode.bytes = 0;\
    E2.decode = function (C, length) \{\
        if (!length) \{\
            length = 0;\
        \}\
        let length_23 = length;\
        let R = \{\};\
        let readUInt16BE = C.readUInt16BE(length);\
        length += 2;\
        R.usage = C.readUInt8(length);\
        length += 1;\
        R.selector = C.readUInt8(length);\
        length += 1;\
        R.matchingType = C.readUInt8(length);\
        length += 1;\
        R.certificate = C.slice(length, length_23 + readUInt16BE + 2);\
        length += R.certificate.length;\
        E2.decode.bytes = length - length_23;\
        return R;\
    \};\
    E2.decode.bytes = 0;\
    E2.encodingLength = function (C) \{\
        return 5 + buffer_3.byteLength(C.certificate);\
    \};\
    var u2 = element.record = function (C) \{\
        switch (C.toUpperCase()) \{\
        case 'A':\
            return P2;\
        case 'PTR':\
            return cname;\
        case 'CNAME':\
            return LA;\
        case 'DNAME':\
            return qA;\
        case 'TXT':\
            return Y2;\
        case 'NULL':\
            return H2;\
        case 'AAAA':\
            return M2;\
        case 'SRV':\
            return I2;\
        case 'HINFO':\
            return X2;\
        case 'CAA':\
            return b;\
        case 'NS':\
            return R2;\
        case 'SOA':\
            return T2;\
        case 'MX':\
            return U2;\
        case 'OPT':\
            return i;\
        case 'DNSKEY':\
            return p;\
        case 'RRSIG':\
            return t;\
        case 'RP':\
            return f;\
        case 'NSEC':\
            return S2;\
        case 'NSEC3':\
            return A2;\
        case 'SSHFP':\
            return u;\
        case 'DS':\
            return C2;\
        case 'NAPTR':\
            return N2;\
        case 'TLSA':\
            return E2;\
        \}\
        return K2;\
    \};\
    var l = element.answer = \{\};\
    l.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(l.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_17 = bytes;\
        G.encode(C.name, alloc, bytes);\
        bytes += G.encode.bytes;\
        alloc.writeUInt16BE(js_1.toType(C.type), bytes);\
        if (C.type.toUpperCase() === 'OPT') \{\
            if (C.name !== '.') \{\
                throw new Error('OPT name must be root.');\
            \}\
            alloc.writeUInt16BE(C.udpPayloadSize || 4096, bytes + 2);\
            alloc.writeUInt8(C.extendedRcode || 0, bytes + 4);\
            alloc.writeUInt8(C.ednsVersion || 0, bytes + 5);\
            alloc.writeUInt16BE(C.flags || 0, bytes + 6);\
            bytes += 8;\
            i.encode(C.options || [], alloc, bytes);\
            bytes += i.encode.bytes;\
        \} else \{\
            let H = _S_1.toClass(C.class === undefined ? 'IN' : C.class);\
            if (C.flush) \{\
                H |= 32768;\
            \}\
            alloc.writeUInt16BE(H, bytes + 2);\
            alloc.writeUInt32BE(C.ttl || 0, bytes + 4);\
            bytes += 8;\
            let M = u2(C.type);\
            M.encode(C.data, alloc, bytes);\
            bytes += M.encode.bytes;\
        \}\
        l.encode.bytes = bytes - bytes_17;\
        return alloc;\
    \};\
    l.encode.bytes = 0;\
    l.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let N = \{\};\
        let bytes_18 = bytes;\
        N.name = G.decode(C, bytes);\
        bytes += G.decode.bytes;\
        N.type = js_1.toString(C.readUInt16BE(bytes));\
        if (N.type === 'OPT') \{\
            N.udpPayloadSize = C.readUInt16BE(bytes + 2);\
            N.extendedRcode = C.readUInt8(bytes + 4);\
            N.ednsVersion = C.readUInt8(bytes + 5);\
            N.flags = C.readUInt16BE(bytes + 6);\
            N.flag_do = (N.flags >> 15 & 1) === 1;\
            N.options = i.decode(C, bytes + 8);\
            bytes += 8 + i.decode.bytes;\
        \} else \{\
            let H = C.readUInt16BE(bytes + 2);\
            N.ttl = C.readUInt32BE(bytes + 4);\
            N.class = _S_1.toString(H & -32769);\
            N.flush = !!(H & 32768);\
            let M = u2(N.type);\
            N.data = M.decode(C, bytes + 8);\
            bytes += 8 + M.decode.bytes;\
        \}\
        l.decode.bytes = bytes - bytes_18;\
        return N;\
    \};\
    l.decode.bytes = 0;\
    l.encodingLength = function (C) \{\
        let S = C.data !== null && C.data !== undefined ? C.data : C.options;\
        return G.encodingLength(C.name) + 8 + u2(C.type).encodingLength(S);\
    \};\
    var s = element.question = \{\};\
    s.encode = function (C, alloc, bytes) \{\
        if (!alloc) \{\
            alloc = buffer_3.alloc(s.encodingLength(C));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_19 = bytes;\
        G.encode(C.name, alloc, bytes);\
        bytes += G.encode.bytes;\
        alloc.writeUInt16BE(js_1.toType(C.type), bytes);\
        bytes += 2;\
        alloc.writeUInt16BE(_S_1.toClass(C.class === undefined ? 'IN' : C.class), bytes);\
        bytes += 2;\
        s.encode.bytes = bytes - bytes_19;\
        return C;\
    \};\
    s.encode.bytes = 0;\
    s.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_20 = bytes;\
        let R = \{\};\
        R.name = G.decode(C, bytes);\
        bytes += G.decode.bytes;\
        R.type = js_1.toString(C.readUInt16BE(bytes));\
        bytes += 2;\
        R.class = _S_1.toString(C.readUInt16BE(bytes));\
        bytes += 2;\
        if (!!(R.class & 32768)) \{\
            R.class &= -32769;\
        \}\
        s.decode.bytes = bytes - bytes_20;\
        return R;\
    \};\
    s.decode.bytes = 0;\
    s.encodingLength = function (C) \{\
        return G.encodingLength(C.name) + 4;\
    \};\
    element.AUTHORITATIVE_ANSWER = 1024;\
    element.TRUNCATED_RESPONSE = 512;\
    element.RECURSION_DESIRED = 256;\
    element.RECURSION_AVAILABLE = 128;\
    element.AUTHENTIC_DATA = 32;\
    element.CHECKING_DISABLED = 16;\
    element.DNSSEC_OK = 32768;\
    element.encode = function (input, alloc, bytes) \{\
        let alloc_1 = !alloc;\
        if (alloc_1) \{\
            alloc = buffer_3.alloc(element.encodingLength(input));\
        \}\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_21 = bytes;\
        if (!input.questions) \{\
            input.questions = [];\
        \}\
        if (!input.answers) \{\
            input.answers = [];\
        \}\
        if (!input.authorities) \{\
            input.authorities = [];\
        \}\
        if (!input.additionals) \{\
            input.additionals = [];\
        \}\
        o.encode(input, alloc, bytes);\
        bytes += o.encode.bytes;\
        bytes = z2(input.questions, s, alloc, bytes);\
        bytes = z2(input.answers, l, alloc, bytes);\
        bytes = z2(input.authorities, l, alloc, bytes);\
        bytes = z2(input.additionals, l, alloc, bytes);\
        element.encode.bytes = bytes - bytes_21;\
        if (alloc_1 && element.encode.bytes !== alloc.length) \{\
            return alloc.slice(0, element.encode.bytes);\
        \}\
        return alloc;\
    \};\
    element.encode.bytes = 0;\
    element.decode = function (C, bytes) \{\
        if (!bytes) \{\
            bytes = 0;\
        \}\
        let bytes_22 = bytes;\
        let decode = o.decode(C, bytes);\
        bytes += o.decode.bytes;\
        bytes = v2(decode.questions, s, C, bytes);\
        bytes = v2(decode.answers, l, C, bytes);\
        bytes = v2(decode.authorities, l, C, bytes);\
        bytes = v2(decode.additionals, l, C, bytes);\
        element.decode.bytes = bytes - bytes_22;\
        return decode;\
    \};\
    element.decode.bytes = 0;\
    element.encodingLength = function (C) \{\
        return o.encodingLength(C) + $2(C.questions || [], s) + $2(C.answers || [], l) + $2(C.authorities || [], l) + $2(C.additionals || [], l);\
    \};\
    element.streamEncode = function (C) \{\
        let encode = element.encode(C);\
        let alloc = buffer_3.alloc(2);\
        alloc.writeUInt16BE(encode.byteLength);\
        let concat = buffer_3.concat([\
            alloc,\
            encode\
        ]);\
        element.streamEncode.bytes = concat.byteLength;\
        return concat;\
    \};\
    element.streamEncode.bytes = 0;\
    element.streamDecode = function (C) \{\
        let readUInt16BE = C.readUInt16BE(0);\
        if (C.byteLength < readUInt16BE + 2) \{\
            return null;\
        \}\
        let decode = element.decode(C.slice(2));\
        element.streamDecode.bytes = element.decode.bytes;\
        return decode;\
    \};\
    element.streamDecode.bytes = 0;\
    function $2(C, S) \{\
        let _num = 0;\
        for (let R = 0; R < C.length; R++) \{\
            _num += S.encodingLength(C[R]);\
        \}\
        return _num;\
    \}\
    function z2(C, S, N, bytes) \{\
        for (let H = 0; H < C.length; H++) \{\
            S.encode(C[H], N, bytes);\
            bytes += S.encode.bytes;\
        \}\
        return bytes;\
    \}\
    function v2(C, S, N, bytes) \{\
        for (let H = 0; H < C.length; H++) \{\
            C[H] = S.decode(N, bytes);\
            bytes += S.decode.bytes;\
        \}\
        return bytes;\
    \}\
\});\
var i2 = vS();\
p2();\
var \{Buffer: gA\} = TS(l2);\
var fromEntries;\
if (typeof $argument != 'undefined') \{\
    fromEntries = Object.fromEntries($argument.split('&').map(element => element.split('=')));\
\} else \{\
    fromEntries = \{\};\
\}\
function Q2(...C) \{\
    if (`$\{ fromEntries?.log \}` === '1') \{\
        console.log(...C);\
    \}\
\}\
Q2(`\uc0\u20256 \u20837 \u30340  $argument: $\{ JSON.stringify(fromEntries, null, 2) \}`);\
var r2 = \{\
    addresses: [],\
    ttl: parseInt(fromEntries?.ttl || 60)\
\};\
(async () => \{\
    let filter = fromEntries?.type || 'A,AAAA';\
    filter = filter.split(/\\s*,\\s*/).filter(element => [\
        'A',\
        'AAAA'\
    ].includes(element));\
    let filter_1 = fromEntries?.doh || 'https://8.8.4.4/dns-query';\
    filter_1 = filter_1.split(/\\s*,\\s*/).filter(element => /https?:\\/\\//.test(element));\
    let _domain = $domain;\
    let _timeout = parseInt(fromEntries?.timeout || 2);\
    let _edns;\
    if (fromEntries?.edns === 'auto') \{\
        try \{\
            _edns = JSON.parse(await $persistentStore.read('lastNetworkInfoEvent'))?.CN_IP;\
            Q2(`\uc0\u20174 \u25345 \u20037 \u21270 \u32531 \u23384 \u35299 \u26512  CN_IP: $\{ _edns \}`);\
        \} catch (W) \{\
            Q2(`\uc0\u20174 \u25345 \u20037 \u21270 \u32531 \u23384 \u35299 \u26512  CN_IP \u22833 \u36133 : $\{ W \}`);\
        \}\
    \} else \{\
        _edns = fromEntries?.edns;\
    \}\
    _edns = _edns || '114.114.114.114';\
    Q2(`\uc0\u20351 \u29992  edns: $\{ _edns \}`);\
    Q2(`[$\{ _domain \}] \uc0\u20351 \u29992  $\{ filter_1.join(', ') \} \u26597 \u35810  $\{ filter \} \u32467 \u26524 `);\
    let map = filter_1.map(async element => \{\
        let _all = await Promise.all(filter.map(element_5 => lA(\{\
            url: element,\
            domain: _domain,\
            type: element_5,\
            timeout: _timeout,\
            edns: _edns\
        \})));\
        let addresses = [];\
        let _ttl_1 = parseInt(fromEntries?.ttl || 60);\
        _all.forEach(element_6 => \{\
            element_6.answers.forEach(element_7 => \{\
                if (filter.includes(element_7.type)) \{\
                    addresses.push(element_7.data);\
                    if (element_7.ttl > 0) \{\
                        _ttl_1 = element_7.ttl;\
                    \}\
                \}\
            \});\
        \});\
        if (addresses.length === 0) \{\
            throw new Error(`[$\{ _domain \}] $\{ element \} \uc0\u26597 \u35810 \u32467 \u26524 \u20026 \u31354 `);\
        \}\
        return \{\
            url: element,\
            addresses: addresses,\
            ttl: _ttl_1\
        \};\
    \});\
    let \{\
        url: V,\
        addresses: _addresses,\
        ttl: _ttl\
    \} = await Promise.any(map);\
    Q2(`[$\{ _domain \}] \uc0\u26368 \u24555 \u21709 \u24212 \u26469 \u33258 : $\{ V \}`);\
    r2 = \{\
        addresses: _addresses,\
        ttl: _ttl\
    \};\
\})().catch(async element => \{\
    Q2(element);\
    if (`$\{ fromEntries?.fallback \}` === '1') \{\
        r2 = \{\};\
    \}\
\}).finally(async () => \{\
    $done(r2);\
\});\
function hA(C) \{\
    return /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)(\\.(?!$)|$))\{4\}$/.test(C);\
\}\
async function lA(\{\
    url: C,\
    domain: _name,\
    type: _type = 'A',\
    timeout: _timeout,\
    edns: _ip\
\}) \{\
    let encode = i2.encode(\{\
        type: 'query',\
        id: 0,\
        flags: i2.RECURSION_DESIRED,\
        questions: [\{\
                type: _type,\
                name: _name\
            \}],\
        additionals: [\{\
                type: 'OPT',\
                name: '.',\
                udpPayloadSize: 4096,\
                flags: 0,\
                options: [\{\
                        code: 'CLIENT_SUBNET',\
                        ip: _ip,\
                        sourcePrefixLength: hA(_ip) ? 24 : 56,\
                        scopePrefixLength: 0\
                    \}]\
            \}]\
    \});\
    let pA_1 = await pA_1(\{\
        url: `$\{ C \}?dns=$\{ encode.toString('base64').toString('utf-8').replace(/=/g, '') \}`,\
        headers: \{ Accept: 'application/dns-message' \},\
        'binary-mode': true,\
        encoding: null,\
        timeout: _timeout,\
        policy: `$\{ fromEntries?.policy \}` === '0' ? undefined : fromEntries?.policy\
    \});\
    return i2.decode(gA.from(pA_1.body));\
\}\
async function pA(C) \{\
    return new Promise((S, N) => \{\
        $httpClient.get(C, (_error, H, body) => \{\
            if (H) \{\
                H.body = body;\
                S(H, \{ error: _error \});\
            \} else \{\
                S(null, \{ error: _error \});\
            \}\
        \});\
    \});\
\}}